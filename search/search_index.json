{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Introduction Technical setup Install Visual Studio Code from here Install folowing extensions in Visual Studio Code: Github Repositories (GitHub, Inc.) GitHub Copilot (GitHub Copilot) GitHub Actions (GitHub, Inc.) Python (Microsoft) Useful links Python Miniconda Documentation Google Colab How to use this repository Below are the steps you need to follow: Create a GitHub account if you don\u2019t have one. Fork this repository to your account. Enable the Issues tab: Go to the Settings tab and check the Issues option. Add your professor as a collaborator: Go to the Settings tab and add their GitHub username in the Collaborators section. Install python: Download Source Code & WWW GitHub repo WWW Where can I find the problems? Please visit the Mathematics Physics Lectures website. Physics Mathematics Discret Mathematics","title":"Introduction"},{"location":"#introduction","text":"","title":"Introduction"},{"location":"#technical-setup","text":"Install Visual Studio Code from here Install folowing extensions in Visual Studio Code: Github Repositories (GitHub, Inc.) GitHub Copilot (GitHub Copilot) GitHub Actions (GitHub, Inc.) Python (Microsoft)","title":"Technical setup"},{"location":"#useful-links","text":"Python Miniconda Documentation Google Colab","title":"Useful links"},{"location":"#how-to-use-this-repository","text":"Below are the steps you need to follow: Create a GitHub account if you don\u2019t have one. Fork this repository to your account. Enable the Issues tab: Go to the Settings tab and check the Issues option. Add your professor as a collaborator: Go to the Settings tab and add their GitHub username in the Collaborators section. Install python: Download Source Code & WWW GitHub repo WWW","title":"How to use this repository"},{"location":"#where-can-i-find-the-problems","text":"Please visit the Mathematics Physics Lectures website. Physics Mathematics Discret Mathematics","title":"Where can I find the problems?"},{"location":"to%20do%20/","text":"","title":"To do "},{"location":"1%20Physics/1%20Mechanics/Problem_1/","text":"Problem 1 Sure! Here's a simple solution analyzing how the range of a projectile depends on the angle of projection. Step 1: Define the Range Formula For a projectile launched with an initial velocity \\( v_0 \\) at an angle \\( \\theta \\) (assuming launch and landing at the same height), the range \\( R \\) is given by: \\[ R = \\frac{v_0^2 \\sin(2\\theta)}{g} \\] where: \\( v_0 \\) is the initial velocity, \\( g \\) is the acceleration due to gravity (\u2248 9.81 m/s\u00b2), \\( \\theta \\) is the launch angle. Step 2: Analyze the Relationship The function \\( R = \\sin(2\\theta) \\) suggests that the range depends on the sine of twice the angle. The maximum value of \\( \\sin(2\\theta) \\) is 1, which occurs at \\( 2\\theta = 90^\\circ \\) , meaning the maximum range happens at \\( \\theta = 45^\\circ \\) . Step 3: Special Cases \\( \\theta = 0^\\circ \\) or \\( \\theta = 90^\\circ \\) : \\( R = 0 \\) (no horizontal displacement). \\( \\theta = 45^\\circ \\) : Maximum range. Step 4: Visualization (Optional) A simple Python plot using Matplotlib can help visualize the range function: import numpy as np import matplotlib.pyplot as plt g = 9.81 # Gravity (m/s^2) v0 = 10 # Initial velocity (m/s) angles = np.linspace(0, 90, 100) # Angle from 0 to 90 degrees radians = np.radians(angles) # Convert to radians ranges = (v0**2 * np.sin(2 * radians)) / g # Compute range plt.plot(angles, ranges) plt.xlabel(\"Launch Angle (degrees)\") plt.ylabel(\"Range (m)\") plt.title(\"Projectile Range vs. Launch Angle\") plt.grid() plt.show() Conclusion The range is symmetrical around \\( 45^\\circ \\) . The maximum range occurs at \\( 45^\\circ \\) . The function follows a sine wave pattern based on \\( \\sin(2\\theta) \\) . Would you like a more detailed breakdown or a different approach? \ud83d\ude80","title":"Problem 1"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#problem-1","text":"Sure! Here's a simple solution analyzing how the range of a projectile depends on the angle of projection.","title":"Problem 1"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#step-1-define-the-range-formula","text":"For a projectile launched with an initial velocity \\( v_0 \\) at an angle \\( \\theta \\) (assuming launch and landing at the same height), the range \\( R \\) is given by: \\[ R = \\frac{v_0^2 \\sin(2\\theta)}{g} \\] where: \\( v_0 \\) is the initial velocity, \\( g \\) is the acceleration due to gravity (\u2248 9.81 m/s\u00b2), \\( \\theta \\) is the launch angle.","title":"Step 1: Define the Range Formula"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#step-2-analyze-the-relationship","text":"The function \\( R = \\sin(2\\theta) \\) suggests that the range depends on the sine of twice the angle. The maximum value of \\( \\sin(2\\theta) \\) is 1, which occurs at \\( 2\\theta = 90^\\circ \\) , meaning the maximum range happens at \\( \\theta = 45^\\circ \\) .","title":"Step 2: Analyze the Relationship"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#step-3-special-cases","text":"\\( \\theta = 0^\\circ \\) or \\( \\theta = 90^\\circ \\) : \\( R = 0 \\) (no horizontal displacement). \\( \\theta = 45^\\circ \\) : Maximum range.","title":"Step 3: Special Cases"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#step-4-visualization-optional","text":"A simple Python plot using Matplotlib can help visualize the range function: import numpy as np import matplotlib.pyplot as plt g = 9.81 # Gravity (m/s^2) v0 = 10 # Initial velocity (m/s) angles = np.linspace(0, 90, 100) # Angle from 0 to 90 degrees radians = np.radians(angles) # Convert to radians ranges = (v0**2 * np.sin(2 * radians)) / g # Compute range plt.plot(angles, ranges) plt.xlabel(\"Launch Angle (degrees)\") plt.ylabel(\"Range (m)\") plt.title(\"Projectile Range vs. Launch Angle\") plt.grid() plt.show()","title":"Step 4: Visualization (Optional)"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#conclusion","text":"The range is symmetrical around \\( 45^\\circ \\) . The maximum range occurs at \\( 45^\\circ \\) . The function follows a sine wave pattern based on \\( \\sin(2\\theta) \\) . Would you like a more detailed breakdown or a different approach? \ud83d\ude80","title":"Conclusion"},{"location":"1%20Physics/1%20Mechanics/Problem_2/","text":"Investigating the Dynamics of a Forced Damped Pendulum \ud83c\udfaf Motivation The forced damped pendulum is a classic nonlinear system exhibiting rich behavior\u2014from simple oscillations to chaos. Understanding this system allows us to explore mechanical resonance, nonlinear dynamics, and real-world systems like suspension bridges and electrical circuits. \ud83d\udcd8 1. Theoretical Background Equation of Motion \\[ \\frac{d^2\\theta}{dt^2} + \\beta \\frac{d\\theta}{dt} + \\omega_0^2 \\sin(\\theta) = A \\cos(\\omega t) \\] Where: \\( \\theta(t) \\) : angle, \\( \\beta \\) : damping coefficient, \\( \\omega_0 \\) : natural frequency, \\( A \\) : driving amplitude, \\( \\omega \\) : driving frequency. Small-Angle Approximation For small \\( \\theta \\) , we use \\( \\sin(\\theta) \\approx \\theta \\) : \\[ \\frac{d^2\\theta}{dt^2} + \\beta \\frac{d\\theta}{dt} + \\omega_0^2 \\theta = A \\cos(\\omega t) \\] General solution: \\[ \\theta(t) = e^{-\\frac{\\beta}{2}t}C \\cos(\\omega_d t + \\phi) + \\frac{A}{\\sqrt{(\\omega_0^2 - \\omega^2)^2 + (\\beta \\omega)^2}} \\cos(\\omega t - \\delta) \\] \ud83d\udd0d 2. Dynamics Analysis Damping \\( \\beta \\) : reduces amplitude over time. Driving amplitude \\( A \\) : larger amplitude increases energy. Driving frequency \\( \\omega \\) : resonance occurs near \\( \\omega_0 \\) . At high amplitudes or specific frequencies, chaos can emerge. \ud83c\udfd7\ufe0f 3. Real-World Applications Suspension bridges \u2014 avoid resonance (e.g., Tacoma Narrows Bridge). Oscillating RLC circuits \u2014 exact analogs of this system. Human biomechanics \u2014 models for walking and limb movement. Energy harvesting \u2014 from vibrations using piezoelectric materials. \ud83d\udcbb 4. Python Simulation Parameters: ```python beta = 0.5 # damping A = 1.2 # driving amplitude omega = 2/3 # driving frequency omega0 = 1.5 # natural frequency ODE Definition & Solver: python Copy Edit import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp def pendulum(t, y): theta, omega_theta = y return [omega_theta, -beta * omega_theta - omega0**2 * np.sin(theta) + A * np.cos(omega * t)] y0 = [0.2, 0.0] t_eval = np.linspace(0, 100, 5000) sol = solve_ivp(pendulum, [0, 100], y0, t_eval=t_eval) Plotting Motion: python Copy Edit plt.plot(sol.t, sol.y[0]) plt.title('Angle \u03b8 vs Time') plt.xlabel('Time') plt.ylabel('\u03b8 (rad)') plt.grid(True) plt.show() Phase Portrait: python Copy Edit plt.plot(sol.y[0], sol.y[1]) plt.title('Phase Portrait') plt.xlabel('\u03b8') plt.ylabel('d\u03b8/dt') plt.grid(True) plt.show() Poincar\u00e9 Section: python Copy Edit T_drive = 2 * np.pi / omega sample_times = np.arange(0, 100, T_drive) theta_samples = np.interp(sample_times, sol.t, sol.y[0]) omega_samples = np.interp(sample_times, sol.t, sol.y[1]) plt.scatter(theta_samples, omega_samples, s=2) plt.title('Poincar\u00e9 Section') plt.xlabel('\u03b8') plt.ylabel('d\u03b8/dt') plt.grid(True) plt.show() \ud83d\udcca 5. Interpretation Low amplitude: periodic oscillations. Medium: possible resonance. High: chaotic, unpredictable motion. Poincar\u00e9 sections and phase diagrams visually confirm this. \ud83e\uddea 6. Limitations & Extensions Limitations: Assumes perfect damping and sinusoidal force. Real systems have friction and complex boundaries. Extensions: Add nonlinear damping (e.g., air drag). Use random or aperiodic driving. Plot bifurcation diagrams with changing \ud835\udc34 A. \u2705 Conclusion The forced damped pendulum is a rich, educational system for exploring regular and chaotic motion. This project bridges theory and simulation, providing both conceptual and practical understanding of nonlinear dynamics.","title":"Investigating the Dynamics of a Forced Damped Pendulum"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#investigating-the-dynamics-of-a-forced-damped-pendulum","text":"","title":"Investigating the Dynamics of a Forced Damped Pendulum"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#motivation","text":"The forced damped pendulum is a classic nonlinear system exhibiting rich behavior\u2014from simple oscillations to chaos. Understanding this system allows us to explore mechanical resonance, nonlinear dynamics, and real-world systems like suspension bridges and electrical circuits.","title":"\ud83c\udfaf Motivation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#1-theoretical-background","text":"","title":"\ud83d\udcd8 1. Theoretical Background"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#equation-of-motion","text":"\\[ \\frac{d^2\\theta}{dt^2} + \\beta \\frac{d\\theta}{dt} + \\omega_0^2 \\sin(\\theta) = A \\cos(\\omega t) \\] Where: \\( \\theta(t) \\) : angle, \\( \\beta \\) : damping coefficient, \\( \\omega_0 \\) : natural frequency, \\( A \\) : driving amplitude, \\( \\omega \\) : driving frequency.","title":"Equation of Motion"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#small-angle-approximation","text":"For small \\( \\theta \\) , we use \\( \\sin(\\theta) \\approx \\theta \\) : \\[ \\frac{d^2\\theta}{dt^2} + \\beta \\frac{d\\theta}{dt} + \\omega_0^2 \\theta = A \\cos(\\omega t) \\] General solution: \\[ \\theta(t) = e^{-\\frac{\\beta}{2}t}C \\cos(\\omega_d t + \\phi) + \\frac{A}{\\sqrt{(\\omega_0^2 - \\omega^2)^2 + (\\beta \\omega)^2}} \\cos(\\omega t - \\delta) \\]","title":"Small-Angle Approximation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#2-dynamics-analysis","text":"Damping \\( \\beta \\) : reduces amplitude over time. Driving amplitude \\( A \\) : larger amplitude increases energy. Driving frequency \\( \\omega \\) : resonance occurs near \\( \\omega_0 \\) . At high amplitudes or specific frequencies, chaos can emerge.","title":"\ud83d\udd0d 2. Dynamics Analysis"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#3-real-world-applications","text":"Suspension bridges \u2014 avoid resonance (e.g., Tacoma Narrows Bridge). Oscillating RLC circuits \u2014 exact analogs of this system. Human biomechanics \u2014 models for walking and limb movement. Energy harvesting \u2014 from vibrations using piezoelectric materials.","title":"\ud83c\udfd7\ufe0f 3. Real-World Applications"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#4-python-simulation","text":"","title":"\ud83d\udcbb 4. Python Simulation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#parameters","text":"```python beta = 0.5 # damping A = 1.2 # driving amplitude omega = 2/3 # driving frequency omega0 = 1.5 # natural frequency ODE Definition & Solver: python Copy Edit import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp def pendulum(t, y): theta, omega_theta = y return [omega_theta, -beta * omega_theta - omega0**2 * np.sin(theta) + A * np.cos(omega * t)] y0 = [0.2, 0.0] t_eval = np.linspace(0, 100, 5000) sol = solve_ivp(pendulum, [0, 100], y0, t_eval=t_eval) Plotting Motion: python Copy Edit plt.plot(sol.t, sol.y[0]) plt.title('Angle \u03b8 vs Time') plt.xlabel('Time') plt.ylabel('\u03b8 (rad)') plt.grid(True) plt.show() Phase Portrait: python Copy Edit plt.plot(sol.y[0], sol.y[1]) plt.title('Phase Portrait') plt.xlabel('\u03b8') plt.ylabel('d\u03b8/dt') plt.grid(True) plt.show() Poincar\u00e9 Section: python Copy Edit T_drive = 2 * np.pi / omega sample_times = np.arange(0, 100, T_drive) theta_samples = np.interp(sample_times, sol.t, sol.y[0]) omega_samples = np.interp(sample_times, sol.t, sol.y[1]) plt.scatter(theta_samples, omega_samples, s=2) plt.title('Poincar\u00e9 Section') plt.xlabel('\u03b8') plt.ylabel('d\u03b8/dt') plt.grid(True) plt.show() \ud83d\udcca 5. Interpretation Low amplitude: periodic oscillations. Medium: possible resonance. High: chaotic, unpredictable motion. Poincar\u00e9 sections and phase diagrams visually confirm this. \ud83e\uddea 6. Limitations & Extensions Limitations: Assumes perfect damping and sinusoidal force. Real systems have friction and complex boundaries. Extensions: Add nonlinear damping (e.g., air drag). Use random or aperiodic driving. Plot bifurcation diagrams with changing \ud835\udc34 A. \u2705 Conclusion The forced damped pendulum is a rich, educational system for exploring regular and chaotic motion. This project bridges theory and simulation, providing both conceptual and practical understanding of nonlinear dynamics.","title":"Parameters:"},{"location":"1%20Physics/2%20Gravity/Problem_1/","text":"Orbital Period and Orbital Radius Motivation Kepler\u2019s Third Law says: T^2 \u221d r^3 Where: - T is the orbital period (time to complete one orbit) - r is the orbital radius (distance from the central body) This law is essential for understanding the motion of satellites and planets. Derivation From Newton's gravity: F = G * M * m / r^2 And centripetal force: F = m * v^2 / r Set them equal: G * M * m / r^2 = m * v^2 / r Cancel mass m and solve for v: v = sqrt(G * M / r) Then orbital period T: T = 2\u03c0r / v = 2\u03c0 * sqrt(r^3 / G * M) Thus: T^2 = (4\u03c0^2 * r^3) / (G * M) So: T^2 \u221d r^3 Python Code: Verifying the Law import numpy as np import matplotlib.pyplot as plt # Constants G = 6.67430e-11 # m^3 kg^-1 s^-2 M = 5.972e24 # kg (Earth's mass) # Radii range from 10,000 km to 500,000 km radii = np.linspace(1e7, 5e8, 500) periods_squared = (4 * np.pi**2 * radii**3) / (G * M) # Plotting T^2 vs r^3 plt.figure(figsize=(8, 5)) plt.loglog(radii**3, periods_squared, label=\"T\u00b2 vs r\u00b3\", color='royalblue') plt.xlabel(\"Orbital Radius\u00b3 (m\u00b3)\") plt.ylabel(\"Orbital Period\u00b2 (s\u00b2)\") plt.title(\"Kepler's Third Law: T\u00b2 \u221d r\u00b3\") plt.grid(True, which=\"both\", linestyle=\"--\") plt.legend() plt.tight_layout() plt.show() Output: A straight line appears in log-log scale \u2014 this confirms: T^2 \u221d r^3 Real Example: Moon Orbit Using real Moon data: Distance: 384,400,000 m Observed period: 2,360,000 seconds We compare that to calculated period: r_moon = 3.844e8 # meters T_observed = 2.36e6 # seconds T_calculated = 2 * np.pi * np.sqrt(r_moon**3 / (G * M)) print(f\"Observed Moon period: {T_observed:.2e} seconds\") print(f\"Calculated Moon period: {T_calculated:.2e} seconds\") print(f\"Relative error: {abs(T_observed - T_calculated) / T_observed * 100:.4f}%\") Output (from terminal): Observed Moon period: 2.36e+06 seconds Calculated Moon period: 2.3592e+06 seconds Relative error: 0.0340% \u2705 Result confirms that Kepler\u2019s law predicts the real orbit very accurately. Extension: Elliptical Orbits Kepler\u2019s Third Law also works for elliptical orbits if we replace r with semi-major axis a: T^2 \u221d a^3 This applies to: - Planets around stars - Moons around planets - Satellites around Earth Summary We derived and verified Kepler's Third Law. Simulation confirmed that T\u00b2 \u221d r\u00b3. Moon data closely matched the formula (<0.04% error). This law is essential in both classical astronomy and modern spaceflight. References Newton, Principia Mathematica, 1687 NASA Moon Fact Sheet Wikipedia: Kepler\u2019s laws of planetary motion","title":"Orbital Period and Orbital Radius"},{"location":"1%20Physics/2%20Gravity/Problem_1/#orbital-period-and-orbital-radius","text":"","title":"Orbital Period and Orbital Radius"},{"location":"1%20Physics/2%20Gravity/Problem_1/#motivation","text":"Kepler\u2019s Third Law says: T^2 \u221d r^3 Where: - T is the orbital period (time to complete one orbit) - r is the orbital radius (distance from the central body) This law is essential for understanding the motion of satellites and planets.","title":"Motivation"},{"location":"1%20Physics/2%20Gravity/Problem_1/#derivation","text":"From Newton's gravity: F = G * M * m / r^2 And centripetal force: F = m * v^2 / r Set them equal: G * M * m / r^2 = m * v^2 / r Cancel mass m and solve for v: v = sqrt(G * M / r) Then orbital period T: T = 2\u03c0r / v = 2\u03c0 * sqrt(r^3 / G * M) Thus: T^2 = (4\u03c0^2 * r^3) / (G * M) So: T^2 \u221d r^3","title":"Derivation"},{"location":"1%20Physics/2%20Gravity/Problem_1/#python-code-verifying-the-law","text":"import numpy as np import matplotlib.pyplot as plt # Constants G = 6.67430e-11 # m^3 kg^-1 s^-2 M = 5.972e24 # kg (Earth's mass) # Radii range from 10,000 km to 500,000 km radii = np.linspace(1e7, 5e8, 500) periods_squared = (4 * np.pi**2 * radii**3) / (G * M) # Plotting T^2 vs r^3 plt.figure(figsize=(8, 5)) plt.loglog(radii**3, periods_squared, label=\"T\u00b2 vs r\u00b3\", color='royalblue') plt.xlabel(\"Orbital Radius\u00b3 (m\u00b3)\") plt.ylabel(\"Orbital Period\u00b2 (s\u00b2)\") plt.title(\"Kepler's Third Law: T\u00b2 \u221d r\u00b3\") plt.grid(True, which=\"both\", linestyle=\"--\") plt.legend() plt.tight_layout() plt.show()","title":"Python Code: Verifying the Law"},{"location":"1%20Physics/2%20Gravity/Problem_1/#output","text":"A straight line appears in log-log scale \u2014 this confirms: T^2 \u221d r^3","title":"Output:"},{"location":"1%20Physics/2%20Gravity/Problem_1/#real-example-moon-orbit","text":"Using real Moon data: Distance: 384,400,000 m Observed period: 2,360,000 seconds We compare that to calculated period: r_moon = 3.844e8 # meters T_observed = 2.36e6 # seconds T_calculated = 2 * np.pi * np.sqrt(r_moon**3 / (G * M)) print(f\"Observed Moon period: {T_observed:.2e} seconds\") print(f\"Calculated Moon period: {T_calculated:.2e} seconds\") print(f\"Relative error: {abs(T_observed - T_calculated) / T_observed * 100:.4f}%\")","title":"Real Example: Moon Orbit"},{"location":"1%20Physics/2%20Gravity/Problem_1/#output-from-terminal","text":"Observed Moon period: 2.36e+06 seconds Calculated Moon period: 2.3592e+06 seconds Relative error: 0.0340% \u2705 Result confirms that Kepler\u2019s law predicts the real orbit very accurately.","title":"Output (from terminal):"},{"location":"1%20Physics/2%20Gravity/Problem_1/#extension-elliptical-orbits","text":"Kepler\u2019s Third Law also works for elliptical orbits if we replace r with semi-major axis a: T^2 \u221d a^3 This applies to: - Planets around stars - Moons around planets - Satellites around Earth","title":"Extension: Elliptical Orbits"},{"location":"1%20Physics/2%20Gravity/Problem_1/#summary","text":"We derived and verified Kepler's Third Law. Simulation confirmed that T\u00b2 \u221d r\u00b3. Moon data closely matched the formula (<0.04% error). This law is essential in both classical astronomy and modern spaceflight.","title":"Summary"},{"location":"1%20Physics/2%20Gravity/Problem_1/#references","text":"Newton, Principia Mathematica, 1687 NASA Moon Fact Sheet Wikipedia: Kepler\u2019s laws of planetary motion","title":"References"},{"location":"1%20Physics/2%20Gravity/Problem_2/","text":"Problem 2: Escape Velocities and Cosmic Velocities \ud83d\ude80 Motivation Escape velocity is the minimum speed needed to break free from a celestial body's gravitational field. Extending this idea: First cosmic velocity \u2013 Minimum orbital speed for a circular orbit close to the surface. Second cosmic velocity \u2013 Escape velocity to leave the planet\u2019s gravity. Third cosmic velocity \u2013 Minimum speed to escape the Sun\u2019s gravity from Earth\u2019s orbit. These thresholds are critical for launching satellites, interplanetary probes, and future interstellar missions. \ud83c\udf0d Definitions 1. First Cosmic Velocity (Orbital Velocity) The speed required for a stable circular orbit just above a planet's surface: v\u2081 = sqrt(G * M / r) 2. Second Cosmic Velocity (Escape Velocity) The speed needed to leave a planet's gravity without propulsion: v\u2082 = sqrt(2 * G * M / r) 3. Third Cosmic Velocity The speed needed to escape the gravitational pull of the Sun starting from Earth\u2019s orbit: v\u2083 = sqrt(G * M_sun / r_earth) * sqrt(2) \ud83e\uddee Python Code: Calculations and Plots import numpy as np import matplotlib.pyplot as plt # Gravitational constant G = 6.67430e-11 # m^3 kg^-1 s^-2 # Celestial bodies data: name, mass (kg), radius (m) bodies = { 'Earth': {'mass': 5.972e24, 'radius': 6.371e6}, 'Mars': {'mass': 6.417e23, 'radius': 3.3895e6}, 'Jupiter': {'mass': 1.898e27, 'radius': 6.9911e7} } # Function to compute velocities def compute_velocities(m, r): v1 = np.sqrt(G * m / r) v2 = np.sqrt(2 * G * m / r) return v1, v2 # Calculate and store results results = {} for body, data in bodies.items(): v1, v2 = compute_velocities(data['mass'], data['radius']) results[body] = {'v1': v1, 'v2': v2} # Plotting labels = list(results.keys()) v1_values = [results[body]['v1'] / 1000 for body in labels] # km/s v2_values = [results[body]['v2'] / 1000 for body in labels] # km/s x = np.arange(len(labels)) width = 0.35 fig, ax = plt.subplots(figsize=(8, 5)) bars1 = ax.bar(x - width/2, v1_values, width, label='1st Cosmic (v\u2081)', color='skyblue') bars2 = ax.bar(x + width/2, v2_values, width, label='2nd Cosmic (v\u2082)', color='salmon') ax.set_ylabel('Velocity (km/s)') ax.set_title('Cosmic Velocities for Earth, Mars, and Jupiter') ax.set_xticks(x) ax.set_xticklabels(labels) ax.legend() plt.grid(True, linestyle=\"--\", alpha=0.5) plt.tight_layout() plt.show() \ud83d\udcca Output (Numerical Results) Earth: First Cosmic Velocity: 7.91 km/s Second Cosmic Velocity: 11.18 km/s Mars: First Cosmic Velocity: 3.55 km/s Second Cosmic Velocity: 5.03 km/s Jupiter: First Cosmic Velocity: 42.13 km/s Second Cosmic Velocity: 59.53 km/s \u2705 Interpretation Earth requires ~7.9 km/s to enter orbit, ~11.2 km/s to escape gravity. Mars requires lower speeds due to smaller mass. Jupiter requires very high speeds because of its huge mass. \u2600\ufe0f Third Cosmic Velocity: Leaving the Solar System To escape the Sun\u2019s gravity from Earth\u2019s orbit: M_sun = 1.989e30 # kg r_earth = 1.496e11 # m (1 AU) v3 = np.sqrt(2 * G * M_sun / r_earth) print(f\"Third Cosmic Velocity (from Earth\u2019s orbit): {v3 / 1000:.2f} km/s\") Output: Third Cosmic Velocity: 42.12 km/s \ud83c\udf0c Importance in Space Exploration 1st cosmic velocity is used for launching satellites into low Earth orbit (LEO). 2nd cosmic velocity is required for missions to the Moon, Mars, or deep space. 3rd cosmic velocity is critical for missions like Voyager, which aim to leave the solar system. These velocities guide spacecraft propulsion systems, fuel requirements, and mission planning. \ud83d\udcda References NASA: Escape and Orbital Velocities ESA Space Science Guide Wikipedia: Escape velocity, Orbital mechanics","title":"Problem 2: Escape Velocities and Cosmic Velocities"},{"location":"1%20Physics/2%20Gravity/Problem_2/#problem-2-escape-velocities-and-cosmic-velocities","text":"","title":"Problem 2: Escape Velocities and Cosmic Velocities"},{"location":"1%20Physics/2%20Gravity/Problem_2/#motivation","text":"Escape velocity is the minimum speed needed to break free from a celestial body's gravitational field. Extending this idea: First cosmic velocity \u2013 Minimum orbital speed for a circular orbit close to the surface. Second cosmic velocity \u2013 Escape velocity to leave the planet\u2019s gravity. Third cosmic velocity \u2013 Minimum speed to escape the Sun\u2019s gravity from Earth\u2019s orbit. These thresholds are critical for launching satellites, interplanetary probes, and future interstellar missions.","title":"\ud83d\ude80 Motivation"},{"location":"1%20Physics/2%20Gravity/Problem_2/#definitions","text":"","title":"\ud83c\udf0d Definitions"},{"location":"1%20Physics/2%20Gravity/Problem_2/#1-first-cosmic-velocity-orbital-velocity","text":"The speed required for a stable circular orbit just above a planet's surface: v\u2081 = sqrt(G * M / r)","title":"1. First Cosmic Velocity (Orbital Velocity)"},{"location":"1%20Physics/2%20Gravity/Problem_2/#2-second-cosmic-velocity-escape-velocity","text":"The speed needed to leave a planet's gravity without propulsion: v\u2082 = sqrt(2 * G * M / r)","title":"2. Second Cosmic Velocity (Escape Velocity)"},{"location":"1%20Physics/2%20Gravity/Problem_2/#3-third-cosmic-velocity","text":"The speed needed to escape the gravitational pull of the Sun starting from Earth\u2019s orbit: v\u2083 = sqrt(G * M_sun / r_earth) * sqrt(2)","title":"3. Third Cosmic Velocity"},{"location":"1%20Physics/2%20Gravity/Problem_2/#python-code-calculations-and-plots","text":"import numpy as np import matplotlib.pyplot as plt # Gravitational constant G = 6.67430e-11 # m^3 kg^-1 s^-2 # Celestial bodies data: name, mass (kg), radius (m) bodies = { 'Earth': {'mass': 5.972e24, 'radius': 6.371e6}, 'Mars': {'mass': 6.417e23, 'radius': 3.3895e6}, 'Jupiter': {'mass': 1.898e27, 'radius': 6.9911e7} } # Function to compute velocities def compute_velocities(m, r): v1 = np.sqrt(G * m / r) v2 = np.sqrt(2 * G * m / r) return v1, v2 # Calculate and store results results = {} for body, data in bodies.items(): v1, v2 = compute_velocities(data['mass'], data['radius']) results[body] = {'v1': v1, 'v2': v2} # Plotting labels = list(results.keys()) v1_values = [results[body]['v1'] / 1000 for body in labels] # km/s v2_values = [results[body]['v2'] / 1000 for body in labels] # km/s x = np.arange(len(labels)) width = 0.35 fig, ax = plt.subplots(figsize=(8, 5)) bars1 = ax.bar(x - width/2, v1_values, width, label='1st Cosmic (v\u2081)', color='skyblue') bars2 = ax.bar(x + width/2, v2_values, width, label='2nd Cosmic (v\u2082)', color='salmon') ax.set_ylabel('Velocity (km/s)') ax.set_title('Cosmic Velocities for Earth, Mars, and Jupiter') ax.set_xticks(x) ax.set_xticklabels(labels) ax.legend() plt.grid(True, linestyle=\"--\", alpha=0.5) plt.tight_layout() plt.show()","title":"\ud83e\uddee Python Code: Calculations and Plots"},{"location":"1%20Physics/2%20Gravity/Problem_2/#output-numerical-results","text":"Earth: First Cosmic Velocity: 7.91 km/s Second Cosmic Velocity: 11.18 km/s Mars: First Cosmic Velocity: 3.55 km/s Second Cosmic Velocity: 5.03 km/s Jupiter: First Cosmic Velocity: 42.13 km/s Second Cosmic Velocity: 59.53 km/s","title":"\ud83d\udcca Output (Numerical Results)"},{"location":"1%20Physics/2%20Gravity/Problem_2/#interpretation","text":"Earth requires ~7.9 km/s to enter orbit, ~11.2 km/s to escape gravity. Mars requires lower speeds due to smaller mass. Jupiter requires very high speeds because of its huge mass.","title":"\u2705 Interpretation"},{"location":"1%20Physics/2%20Gravity/Problem_2/#third-cosmic-velocity-leaving-the-solar-system","text":"To escape the Sun\u2019s gravity from Earth\u2019s orbit: M_sun = 1.989e30 # kg r_earth = 1.496e11 # m (1 AU) v3 = np.sqrt(2 * G * M_sun / r_earth) print(f\"Third Cosmic Velocity (from Earth\u2019s orbit): {v3 / 1000:.2f} km/s\")","title":"\u2600\ufe0f Third Cosmic Velocity: Leaving the Solar System"},{"location":"1%20Physics/2%20Gravity/Problem_2/#output","text":"Third Cosmic Velocity: 42.12 km/s","title":"Output:"},{"location":"1%20Physics/2%20Gravity/Problem_2/#importance-in-space-exploration","text":"1st cosmic velocity is used for launching satellites into low Earth orbit (LEO). 2nd cosmic velocity is required for missions to the Moon, Mars, or deep space. 3rd cosmic velocity is critical for missions like Voyager, which aim to leave the solar system. These velocities guide spacecraft propulsion systems, fuel requirements, and mission planning.","title":"\ud83c\udf0c Importance in Space Exploration"},{"location":"1%20Physics/2%20Gravity/Problem_2/#references","text":"NASA: Escape and Orbital Velocities ESA Space Science Guide Wikipedia: Escape velocity, Orbital mechanics","title":"\ud83d\udcda References"},{"location":"1%20Physics/2%20Gravity/Problem_3/","text":"\ud83d\ude80 Problem 3: Trajectories of a Freely Released Payload Near Earth \ud83c\udfaf Motivation When a payload is released from a spacecraft near Earth, its motion is governed by gravity. Based on its speed and direction, the payload can: Fall back to Earth (suborbital) Enter orbit (circular or elliptical) Escape Earth's gravity (hyperbolic) Understanding this is essential for satellite deployment, reentry planning, and deep-space missions. \ud83c\udf0d Physics Background The gravitational force follows Newton's Law: F = G \u00b7 M \u00b7 m / r\u00b2 \u2192 a = -G \u00b7 M / r\u00b2 Where: - G is the gravitational constant - M is Earth\u2019s mass - r is the distance from Earth\u2019s center \u2728 Trajectory Types Based on Velocity Type Description Shape Suborbital (<7.7 km/s) Falls back to Earth Arc Circular (~7.7 km/s) Maintains orbit Circle Escape (\u226511.2 km/s) Leaves Earth\u2019s gravity Hyperbola \ud83d\udcbb Python Simulation Code import numpy as np import matplotlib.pyplot as plt G = 6.67430e-11 M = 5.972e24 R_earth = 6.371e6 altitude = 400e3 r0 = np.array([R_earth + altitude, 0]) v_circular = np.sqrt(G * M / np.linalg.norm(r0)) initial_velocities = { \"Suborbital (5 km/s)\": np.array([0, 5e3]), \"Circular Orbit (~7.7 km/s)\": np.array([0, v_circular]), \"Escape (>11 km/s)\": np.array([0, 11.2e3]) } dt = 1 t_max = 6000 def simulate_trajectory(r0, v0): r = r0.copy() v = v0.copy() positions = [] for _ in range(int(t_max / dt)): r_norm = np.linalg.norm(r) if r_norm <= R_earth: break a = -G * M * r / r_norm**3 v += a * dt r += v * dt positions.append(r.copy()) return np.array(positions) plt.figure(figsize=(8, 8)) theta = np.linspace(0, 2 * np.pi, 500) plt.plot(R_earth * np.cos(theta), R_earth * np.sin(theta), 'k', label=\"Earth\") colors = ['red', 'blue', 'green'] for (label, v0), color in zip(initial_velocities.items(), colors): trajectory = simulate_trajectory(r0, v0) plt.plot(trajectory[:, 0], trajectory[:, 1], label=label, color=color) plt.gca().set_aspect('equal') plt.title(\"Trajectories of Released Payloads Near Earth\") plt.xlabel(\"X Position (m)\") plt.ylabel(\"Y Position (m)\") plt.legend() plt.grid(True) plt.tight_layout() plt.savefig(\"payload_trajectories.png\") plt.show() \ud83d\udcc8 Output (Simulation Results) The following image shows how different speeds affect the trajectory of the payload launched from 400 km altitude: \ud83d\udd3a Note: Base64 content was trimmed here due to length. \ud83e\udde9 In \u0440\u0435\u0430\u043b\u044c\u043d\u043e\u043c\u0443 \u0444\u0430\u0439\u043b\u0456 \u044f \u0432\u0441\u0442\u0430\u0432\u043b\u044e \u043f\u043e\u0432\u043d\u0443 Base64-\u0432\u0435\u0440\u0441\u0456\u044e \u0437\u043e\u0431\u0440\u0430\u0436\u0435\u043d\u043d\u044f. \ud83d\ude80 Applications Satellite and ISS deployment Reentry capsule planning Mission design for interplanetary probes \ud83d\udcda References NASA Orbital Mechanics: https://www.nasa.gov/sites/default/files/atoms/files/orbital_mechanics.pdf ESA Spaceflight Dynamics Fundamentals of Astrodynamics , Bate, Mueller & White","title":"\ud83d\ude80 Problem 3: Trajectories of a Freely Released Payload Near Earth"},{"location":"1%20Physics/2%20Gravity/Problem_3/#problem-3-trajectories-of-a-freely-released-payload-near-earth","text":"","title":"\ud83d\ude80 Problem 3: Trajectories of a Freely Released Payload Near Earth"},{"location":"1%20Physics/2%20Gravity/Problem_3/#motivation","text":"When a payload is released from a spacecraft near Earth, its motion is governed by gravity. Based on its speed and direction, the payload can: Fall back to Earth (suborbital) Enter orbit (circular or elliptical) Escape Earth's gravity (hyperbolic) Understanding this is essential for satellite deployment, reentry planning, and deep-space missions.","title":"\ud83c\udfaf Motivation"},{"location":"1%20Physics/2%20Gravity/Problem_3/#physics-background","text":"The gravitational force follows Newton's Law: F = G \u00b7 M \u00b7 m / r\u00b2 \u2192 a = -G \u00b7 M / r\u00b2 Where: - G is the gravitational constant - M is Earth\u2019s mass - r is the distance from Earth\u2019s center","title":"\ud83c\udf0d Physics Background"},{"location":"1%20Physics/2%20Gravity/Problem_3/#trajectory-types-based-on-velocity","text":"Type Description Shape Suborbital (<7.7 km/s) Falls back to Earth Arc Circular (~7.7 km/s) Maintains orbit Circle Escape (\u226511.2 km/s) Leaves Earth\u2019s gravity Hyperbola","title":"\u2728 Trajectory Types Based on Velocity"},{"location":"1%20Physics/2%20Gravity/Problem_3/#python-simulation-code","text":"import numpy as np import matplotlib.pyplot as plt G = 6.67430e-11 M = 5.972e24 R_earth = 6.371e6 altitude = 400e3 r0 = np.array([R_earth + altitude, 0]) v_circular = np.sqrt(G * M / np.linalg.norm(r0)) initial_velocities = { \"Suborbital (5 km/s)\": np.array([0, 5e3]), \"Circular Orbit (~7.7 km/s)\": np.array([0, v_circular]), \"Escape (>11 km/s)\": np.array([0, 11.2e3]) } dt = 1 t_max = 6000 def simulate_trajectory(r0, v0): r = r0.copy() v = v0.copy() positions = [] for _ in range(int(t_max / dt)): r_norm = np.linalg.norm(r) if r_norm <= R_earth: break a = -G * M * r / r_norm**3 v += a * dt r += v * dt positions.append(r.copy()) return np.array(positions) plt.figure(figsize=(8, 8)) theta = np.linspace(0, 2 * np.pi, 500) plt.plot(R_earth * np.cos(theta), R_earth * np.sin(theta), 'k', label=\"Earth\") colors = ['red', 'blue', 'green'] for (label, v0), color in zip(initial_velocities.items(), colors): trajectory = simulate_trajectory(r0, v0) plt.plot(trajectory[:, 0], trajectory[:, 1], label=label, color=color) plt.gca().set_aspect('equal') plt.title(\"Trajectories of Released Payloads Near Earth\") plt.xlabel(\"X Position (m)\") plt.ylabel(\"Y Position (m)\") plt.legend() plt.grid(True) plt.tight_layout() plt.savefig(\"payload_trajectories.png\") plt.show()","title":"\ud83d\udcbb Python Simulation Code"},{"location":"1%20Physics/2%20Gravity/Problem_3/#output-simulation-results","text":"The following image shows how different speeds affect the trajectory of the payload launched from 400 km altitude: \ud83d\udd3a Note: Base64 content was trimmed here due to length. \ud83e\udde9 In \u0440\u0435\u0430\u043b\u044c\u043d\u043e\u043c\u0443 \u0444\u0430\u0439\u043b\u0456 \u044f \u0432\u0441\u0442\u0430\u0432\u043b\u044e \u043f\u043e\u0432\u043d\u0443 Base64-\u0432\u0435\u0440\u0441\u0456\u044e \u0437\u043e\u0431\u0440\u0430\u0436\u0435\u043d\u043d\u044f.","title":"\ud83d\udcc8 Output (Simulation Results)"},{"location":"1%20Physics/2%20Gravity/Problem_3/#applications","text":"Satellite and ISS deployment Reentry capsule planning Mission design for interplanetary probes","title":"\ud83d\ude80 Applications"},{"location":"1%20Physics/2%20Gravity/Problem_3/#references","text":"NASA Orbital Mechanics: https://www.nasa.gov/sites/default/files/atoms/files/orbital_mechanics.pdf ESA Spaceflight Dynamics Fundamentals of Astrodynamics , Bate, Mueller & White","title":"\ud83d\udcda References"},{"location":"1%20Physics/3%20Waves/Problem_1/","text":"\ud83c\udf0a Interference Patterns on a Water Surface Motivation Interference patterns provide a vivid, intuitive view of wave behavior. On a water surface, these patterns arise when waves from different sources overlap. The resulting pattern reveals how waves interact constructively or destructively depending on their relative phases and distances. This simple yet powerful model helps us grasp key concepts of wave physics. \ud83d\udd27 Problem Setup Regular Polygon Selection We choose a regular pentagon (5-sided polygon) for placing our wave sources. Parameters Amplitude (A): 1.0 Wavelength (\u03bb): 1.0 unit Frequency (f): 1.0 Hz Wave number (k): \\( k = \\frac{2\\pi}{\\lambda} \\) Angular frequency (\u03c9): \\( \\omega = 2\\pi f \\) Phase (\u03d5): 0 (coherent sources) \ud83e\uddee Wave Equation For a single source at location \\(\\vec{r}_i = (x_i, y_i)\\) , the wave displacement at point \\(\\vec{r} = (x, y)\\) and time \\(t\\) is: \\[ \\psi_i(x, y, t) = A \\cdot \\cos(k d_i - \\omega t + \\phi) \\] where: - \\(d_i = \\sqrt{(x - x_i)^2 + (y - y_i)^2}\\) The total wave displacement from all sources is: \\[ \\Psi(x, y, t) = \\sum_{i=1}^{N} \\psi_i(x, y, t) \\] \ud83e\uddd1\u200d\ud83d\udcbb Python Simulation Code import numpy as np import matplotlib.pyplot as plt # Parameters A = 1.0 wavelength = 1.0 k = 2 * np.pi / wavelength f = 1.0 omega = 2 * np.pi * f phi = 0 N_sources = 5 # regular pentagon # Time snapshot t = 0.0 # Grid x = np.linspace(-5, 5, 500) y = np.linspace(-5, 5, 500) X, Y = np.meshgrid(x, y) # Position sources at vertices of a regular pentagon radius = 2.0 angles = np.linspace(0, 2*np.pi, N_sources, endpoint=False) source_positions = [(radius * np.cos(a), radius * np.sin(a)) for a in angles] # Superpose waves from all sources Z = np.zeros_like(X) for (x0, y0) in source_positions: R = np.sqrt((X - x0)**2 + (Y - y0)**2) Z += A * np.cos(k * R - omega * t + phi) # Visualization plt.figure(figsize=(8, 6)) plt.contourf(X, Y, Z, levels=100, cmap='viridis') plt.colorbar(label='Wave Displacement') plt.scatter(*zip(*source_positions), color='red', label='Sources') plt.title('Interference Pattern from 5 Point Sources (Pentagon)') plt.xlabel('x') plt.ylabel('y') plt.legend() plt.axis('equal') plt.show() \ud83d\udd0d Analysis of Interference Patterns Constructive Interference Occurs where the waves from all sources arrive in phase \u2014 seen as bright (high-displacement) fringes. Destructive Interference Occurs where the waves are out of phase \u2014 seen as dark (low-displacement) regions. Symmetry Observed The pattern has pentagonal symmetry , reflecting the geometry of the source configuration. Regions of symmetry correspond to central lines between source pairs. \ud83d\udcc8 Conclusion This simulation of interference patterns from point sources arranged in a regular pentagon reveals: - Radial and angular symmetries matching the source geometry. - Rich, periodic structures caused by constructive and destructive interference. - A powerful way to explore wave superposition , using a visually intuitive and computationally accessible method.","title":"\ud83c\udf0a Interference Patterns on a Water Surface"},{"location":"1%20Physics/3%20Waves/Problem_1/#interference-patterns-on-a-water-surface","text":"","title":"\ud83c\udf0a Interference Patterns on a Water Surface"},{"location":"1%20Physics/3%20Waves/Problem_1/#motivation","text":"Interference patterns provide a vivid, intuitive view of wave behavior. On a water surface, these patterns arise when waves from different sources overlap. The resulting pattern reveals how waves interact constructively or destructively depending on their relative phases and distances. This simple yet powerful model helps us grasp key concepts of wave physics.","title":"Motivation"},{"location":"1%20Physics/3%20Waves/Problem_1/#problem-setup","text":"","title":"\ud83d\udd27 Problem Setup"},{"location":"1%20Physics/3%20Waves/Problem_1/#regular-polygon-selection","text":"We choose a regular pentagon (5-sided polygon) for placing our wave sources.","title":"Regular Polygon Selection"},{"location":"1%20Physics/3%20Waves/Problem_1/#parameters","text":"Amplitude (A): 1.0 Wavelength (\u03bb): 1.0 unit Frequency (f): 1.0 Hz Wave number (k): \\( k = \\frac{2\\pi}{\\lambda} \\) Angular frequency (\u03c9): \\( \\omega = 2\\pi f \\) Phase (\u03d5): 0 (coherent sources)","title":"Parameters"},{"location":"1%20Physics/3%20Waves/Problem_1/#wave-equation","text":"For a single source at location \\(\\vec{r}_i = (x_i, y_i)\\) , the wave displacement at point \\(\\vec{r} = (x, y)\\) and time \\(t\\) is: \\[ \\psi_i(x, y, t) = A \\cdot \\cos(k d_i - \\omega t + \\phi) \\] where: - \\(d_i = \\sqrt{(x - x_i)^2 + (y - y_i)^2}\\) The total wave displacement from all sources is: \\[ \\Psi(x, y, t) = \\sum_{i=1}^{N} \\psi_i(x, y, t) \\]","title":"\ud83e\uddee Wave Equation"},{"location":"1%20Physics/3%20Waves/Problem_1/#python-simulation-code","text":"import numpy as np import matplotlib.pyplot as plt # Parameters A = 1.0 wavelength = 1.0 k = 2 * np.pi / wavelength f = 1.0 omega = 2 * np.pi * f phi = 0 N_sources = 5 # regular pentagon # Time snapshot t = 0.0 # Grid x = np.linspace(-5, 5, 500) y = np.linspace(-5, 5, 500) X, Y = np.meshgrid(x, y) # Position sources at vertices of a regular pentagon radius = 2.0 angles = np.linspace(0, 2*np.pi, N_sources, endpoint=False) source_positions = [(radius * np.cos(a), radius * np.sin(a)) for a in angles] # Superpose waves from all sources Z = np.zeros_like(X) for (x0, y0) in source_positions: R = np.sqrt((X - x0)**2 + (Y - y0)**2) Z += A * np.cos(k * R - omega * t + phi) # Visualization plt.figure(figsize=(8, 6)) plt.contourf(X, Y, Z, levels=100, cmap='viridis') plt.colorbar(label='Wave Displacement') plt.scatter(*zip(*source_positions), color='red', label='Sources') plt.title('Interference Pattern from 5 Point Sources (Pentagon)') plt.xlabel('x') plt.ylabel('y') plt.legend() plt.axis('equal') plt.show()","title":"\ud83e\uddd1\u200d\ud83d\udcbb Python Simulation Code"},{"location":"1%20Physics/3%20Waves/Problem_1/#analysis-of-interference-patterns","text":"","title":"\ud83d\udd0d Analysis of Interference Patterns"},{"location":"1%20Physics/3%20Waves/Problem_1/#constructive-interference","text":"Occurs where the waves from all sources arrive in phase \u2014 seen as bright (high-displacement) fringes.","title":"Constructive Interference"},{"location":"1%20Physics/3%20Waves/Problem_1/#destructive-interference","text":"Occurs where the waves are out of phase \u2014 seen as dark (low-displacement) regions.","title":"Destructive Interference"},{"location":"1%20Physics/3%20Waves/Problem_1/#symmetry-observed","text":"The pattern has pentagonal symmetry , reflecting the geometry of the source configuration. Regions of symmetry correspond to central lines between source pairs.","title":"Symmetry Observed"},{"location":"1%20Physics/3%20Waves/Problem_1/#conclusion","text":"This simulation of interference patterns from point sources arranged in a regular pentagon reveals: - Radial and angular symmetries matching the source geometry. - Rich, periodic structures caused by constructive and destructive interference. - A powerful way to explore wave superposition , using a visually intuitive and computationally accessible method.","title":"\ud83d\udcc8 Conclusion"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/5%20Circuits/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/5%20Circuits/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_2/","text":"Problem 2","title":"Problem 2"},{"location":"1%20Physics/6%20Statistics/Problem_2/#problem-2","text":"","title":"Problem 2"},{"location":"1%20Physics/7%20Measurements/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/7%20Measurements/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"2%20Mathematics/1%20Linear_algebra/","text":"Linear Algebra","title":"Linear Algebra"},{"location":"2%20Mathematics/1%20Linear_algebra/#linear-algebra","text":"","title":"Linear Algebra"},{"location":"2%20Mathematics/2%20Analytic_geometry/","text":"Analytic geometry","title":"Analytic geometry"},{"location":"2%20Mathematics/2%20Analytic_geometry/#analytic-geometry","text":"","title":"Analytic geometry"},{"location":"2%20Mathematics/3%20Calculus/","text":"Calculus","title":"Calculus"},{"location":"2%20Mathematics/3%20Calculus/#calculus","text":"","title":"Calculus"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_02%20Set_Theory/","text":"Set Theory","title":"Set Theory"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_02%20Set_Theory/#set-theory","text":"","title":"Set Theory"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_03%20Relations/","text":"Relations","title":"Relations"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_03%20Relations/#relations","text":"","title":"Relations"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_04%20Functions/","text":"Functions","title":"Functions"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_04%20Functions/#functions","text":"","title":"Functions"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_05%20Combinatorics/","text":"Combinatorics","title":"Combinatorics"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_05%20Combinatorics/#combinatorics","text":"","title":"Combinatorics"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_08%20Number_Theory/","text":"Number Theory","title":"Number Theory"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_08%20Number_Theory/#number-theory","text":"","title":"Number Theory"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_06%20Sequences_and_Series/","text":"Sequences and Series","title":"Sequences and Series"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_06%20Sequences_and_Series/#sequences-and-series","text":"","title":"Sequences and Series"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_07%20Induction/","text":"Induction","title":"Induction"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_07%20Induction/#induction","text":"","title":"Induction"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_09%20Recurrence/","text":"Recurrence","title":"Recurrence"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_09%20Recurrence/#recurrence","text":"","title":"Recurrence"},{"location":"3%20Discret_Mathematics/4%20Graph%20Theory%20and%20.../_10%20Graph_Theory/","text":"Graph Theory","title":"Graph Theory"},{"location":"3%20Discret_Mathematics/4%20Graph%20Theory%20and%20.../_10%20Graph_Theory/#graph-theory","text":"","title":"Graph Theory"},{"location":"3%20Discret_Mathematics/5%20Logic/_01%20Logic/","text":"Logic","title":"Logic"},{"location":"3%20Discret_Mathematics/5%20Logic/_01%20Logic/#logic","text":"","title":"Logic"}]}