{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Introduction Technical setup Install Visual Studio Code from here Install folowing extensions in Visual Studio Code: Github Repositories (GitHub, Inc.) GitHub Copilot (GitHub Copilot) GitHub Actions (GitHub, Inc.) Python (Microsoft) Useful links Python Miniconda Documentation Google Colab How to use this repository Below are the steps you need to follow: Create a GitHub account if you don\u2019t have one. Fork this repository to your account. Enable the Issues tab: Go to the Settings tab and check the Issues option. Add your professor as a collaborator: Go to the Settings tab and add their GitHub username in the Collaborators section. Install python: Download Source Code & WWW GitHub repo WWW Where can I find the problems? Please visit the Mathematics Physics Lectures website. Physics Mathematics Discret Mathematics","title":"Introduction"},{"location":"#introduction","text":"","title":"Introduction"},{"location":"#technical-setup","text":"Install Visual Studio Code from here Install folowing extensions in Visual Studio Code: Github Repositories (GitHub, Inc.) GitHub Copilot (GitHub Copilot) GitHub Actions (GitHub, Inc.) Python (Microsoft)","title":"Technical setup"},{"location":"#useful-links","text":"Python Miniconda Documentation Google Colab","title":"Useful links"},{"location":"#how-to-use-this-repository","text":"Below are the steps you need to follow: Create a GitHub account if you don\u2019t have one. Fork this repository to your account. Enable the Issues tab: Go to the Settings tab and check the Issues option. Add your professor as a collaborator: Go to the Settings tab and add their GitHub username in the Collaborators section. Install python: Download Source Code & WWW GitHub repo WWW","title":"How to use this repository"},{"location":"#where-can-i-find-the-problems","text":"Please visit the Mathematics Physics Lectures website. Physics Mathematics Discret Mathematics","title":"Where can I find the problems?"},{"location":"to%20do%20/","text":"","title":"To do "},{"location":"1%20Physics/1%20Mechanics/Problem_1/","text":"Problem 1 Sure! Here's a simple solution analyzing how the range of a projectile depends on the angle of projection. Step 1: Define the Range Formula For a projectile launched with an initial velocity \\( v_0 \\) at an angle \\( \\theta \\) (assuming launch and landing at the same height), the range \\( R \\) is given by: \\[ R = \\frac{v_0^2 \\sin(2\\theta)}{g} \\] where: \\( v_0 \\) is the initial velocity, \\( g \\) is the acceleration due to gravity (\u2248 9.81 m/s\u00b2), \\( \\theta \\) is the launch angle. Step 2: Analyze the Relationship The function \\( R = \\sin(2\\theta) \\) suggests that the range depends on the sine of twice the angle. The maximum value of \\( \\sin(2\\theta) \\) is 1, which occurs at \\( 2\\theta = 90^\\circ \\) , meaning the maximum range happens at \\( \\theta = 45^\\circ \\) . Step 3: Special Cases \\( \\theta = 0^\\circ \\) or \\( \\theta = 90^\\circ \\) : \\( R = 0 \\) (no horizontal displacement). \\( \\theta = 45^\\circ \\) : Maximum range. Step 4: Visualization (Optional) A simple Python plot using Matplotlib can help visualize the range function: import numpy as np import matplotlib.pyplot as plt g = 9.81 # Gravity (m/s^2) v0 = 10 # Initial velocity (m/s) angles = np.linspace(0, 90, 100) # Angle from 0 to 90 degrees radians = np.radians(angles) # Convert to radians ranges = (v0**2 * np.sin(2 * radians)) / g # Compute range plt.plot(angles, ranges) plt.xlabel(\"Launch Angle (degrees)\") plt.ylabel(\"Range (m)\") plt.title(\"Projectile Range vs. Launch Angle\") plt.grid() plt.show() Conclusion The range is symmetrical around \\( 45^\\circ \\) . The maximum range occurs at \\( 45^\\circ \\) . The function follows a sine wave pattern based on \\( \\sin(2\\theta) \\) . Would you like a more detailed breakdown or a different approach? \ud83d\ude80","title":"Problem 1"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#problem-1","text":"Sure! Here's a simple solution analyzing how the range of a projectile depends on the angle of projection.","title":"Problem 1"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#step-1-define-the-range-formula","text":"For a projectile launched with an initial velocity \\( v_0 \\) at an angle \\( \\theta \\) (assuming launch and landing at the same height), the range \\( R \\) is given by: \\[ R = \\frac{v_0^2 \\sin(2\\theta)}{g} \\] where: \\( v_0 \\) is the initial velocity, \\( g \\) is the acceleration due to gravity (\u2248 9.81 m/s\u00b2), \\( \\theta \\) is the launch angle.","title":"Step 1: Define the Range Formula"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#step-2-analyze-the-relationship","text":"The function \\( R = \\sin(2\\theta) \\) suggests that the range depends on the sine of twice the angle. The maximum value of \\( \\sin(2\\theta) \\) is 1, which occurs at \\( 2\\theta = 90^\\circ \\) , meaning the maximum range happens at \\( \\theta = 45^\\circ \\) .","title":"Step 2: Analyze the Relationship"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#step-3-special-cases","text":"\\( \\theta = 0^\\circ \\) or \\( \\theta = 90^\\circ \\) : \\( R = 0 \\) (no horizontal displacement). \\( \\theta = 45^\\circ \\) : Maximum range.","title":"Step 3: Special Cases"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#step-4-visualization-optional","text":"A simple Python plot using Matplotlib can help visualize the range function: import numpy as np import matplotlib.pyplot as plt g = 9.81 # Gravity (m/s^2) v0 = 10 # Initial velocity (m/s) angles = np.linspace(0, 90, 100) # Angle from 0 to 90 degrees radians = np.radians(angles) # Convert to radians ranges = (v0**2 * np.sin(2 * radians)) / g # Compute range plt.plot(angles, ranges) plt.xlabel(\"Launch Angle (degrees)\") plt.ylabel(\"Range (m)\") plt.title(\"Projectile Range vs. Launch Angle\") plt.grid() plt.show()","title":"Step 4: Visualization (Optional)"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#conclusion","text":"The range is symmetrical around \\( 45^\\circ \\) . The maximum range occurs at \\( 45^\\circ \\) . The function follows a sine wave pattern based on \\( \\sin(2\\theta) \\) . Would you like a more detailed breakdown or a different approach? \ud83d\ude80","title":"Conclusion"},{"location":"1%20Physics/1%20Mechanics/Problem_2/","text":"Investigating the Dynamics of a Forced Damped Pendulum \ud83c\udfaf Motivation The forced damped pendulum is a classic nonlinear system exhibiting rich behavior\u2014from simple oscillations to chaos. Understanding this system allows us to explore mechanical resonance, nonlinear dynamics, and real-world systems like suspension bridges and electrical circuits. \ud83d\udcd8 1. Theoretical Background Equation of Motion \\[ \\frac{d^2\\theta}{dt^2} + \\beta \\frac{d\\theta}{dt} + \\omega_0^2 \\sin(\\theta) = A \\cos(\\omega t) \\] Where: \\( \\theta(t) \\) : angle, \\( \\beta \\) : damping coefficient, \\( \\omega_0 \\) : natural frequency, \\( A \\) : driving amplitude, \\( \\omega \\) : driving frequency. Small-Angle Approximation For small \\( \\theta \\) , we use \\( \\sin(\\theta) \\approx \\theta \\) : \\[ \\frac{d^2\\theta}{dt^2} + \\beta \\frac{d\\theta}{dt} + \\omega_0^2 \\theta = A \\cos(\\omega t) \\] General solution: \\[ \\theta(t) = e^{-\\frac{\\beta}{2}t}C \\cos(\\omega_d t + \\phi) + \\frac{A}{\\sqrt{(\\omega_0^2 - \\omega^2)^2 + (\\beta \\omega)^2}} \\cos(\\omega t - \\delta) \\] \ud83d\udd0d 2. Dynamics Analysis Damping \\( \\beta \\) : reduces amplitude over time. Driving amplitude \\( A \\) : larger amplitude increases energy. Driving frequency \\( \\omega \\) : resonance occurs near \\( \\omega_0 \\) . At high amplitudes or specific frequencies, chaos can emerge. \ud83c\udfd7\ufe0f 3. Real-World Applications Suspension bridges \u2014 avoid resonance (e.g., Tacoma Narrows Bridge). Oscillating RLC circuits \u2014 exact analogs of this system. Human biomechanics \u2014 models for walking and limb movement. Energy harvesting \u2014 from vibrations using piezoelectric materials. \ud83d\udcbb 4. Python Simulation Parameters: ```python beta = 0.5 # damping A = 1.2 # driving amplitude omega = 2/3 # driving frequency omega0 = 1.5 # natural frequency ODE Definition & Solver: python Copy Edit import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp def pendulum(t, y): theta, omega_theta = y return [omega_theta, -beta * omega_theta - omega0**2 * np.sin(theta) + A * np.cos(omega * t)] y0 = [0.2, 0.0] t_eval = np.linspace(0, 100, 5000) sol = solve_ivp(pendulum, [0, 100], y0, t_eval=t_eval) Plotting Motion: python Copy Edit plt.plot(sol.t, sol.y[0]) plt.title('Angle \u03b8 vs Time') plt.xlabel('Time') plt.ylabel('\u03b8 (rad)') plt.grid(True) plt.show() Phase Portrait: python Copy Edit plt.plot(sol.y[0], sol.y[1]) plt.title('Phase Portrait') plt.xlabel('\u03b8') plt.ylabel('d\u03b8/dt') plt.grid(True) plt.show() Poincar\u00e9 Section: python Copy Edit T_drive = 2 * np.pi / omega sample_times = np.arange(0, 100, T_drive) theta_samples = np.interp(sample_times, sol.t, sol.y[0]) omega_samples = np.interp(sample_times, sol.t, sol.y[1]) plt.scatter(theta_samples, omega_samples, s=2) plt.title('Poincar\u00e9 Section') plt.xlabel('\u03b8') plt.ylabel('d\u03b8/dt') plt.grid(True) plt.show() \ud83d\udcca 5. Interpretation Low amplitude: periodic oscillations. Medium: possible resonance. High: chaotic, unpredictable motion. Poincar\u00e9 sections and phase diagrams visually confirm this. \ud83e\uddea 6. Limitations & Extensions Limitations: Assumes perfect damping and sinusoidal force. Real systems have friction and complex boundaries. Extensions: Add nonlinear damping (e.g., air drag). Use random or aperiodic driving. Plot bifurcation diagrams with changing \ud835\udc34 A. \u2705 Conclusion The forced damped pendulum is a rich, educational system for exploring regular and chaotic motion. This project bridges theory and simulation, providing both conceptual and practical understanding of nonlinear dynamics.","title":"Investigating the Dynamics of a Forced Damped Pendulum"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#investigating-the-dynamics-of-a-forced-damped-pendulum","text":"","title":"Investigating the Dynamics of a Forced Damped Pendulum"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#motivation","text":"The forced damped pendulum is a classic nonlinear system exhibiting rich behavior\u2014from simple oscillations to chaos. Understanding this system allows us to explore mechanical resonance, nonlinear dynamics, and real-world systems like suspension bridges and electrical circuits.","title":"\ud83c\udfaf Motivation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#1-theoretical-background","text":"","title":"\ud83d\udcd8 1. Theoretical Background"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#equation-of-motion","text":"\\[ \\frac{d^2\\theta}{dt^2} + \\beta \\frac{d\\theta}{dt} + \\omega_0^2 \\sin(\\theta) = A \\cos(\\omega t) \\] Where: \\( \\theta(t) \\) : angle, \\( \\beta \\) : damping coefficient, \\( \\omega_0 \\) : natural frequency, \\( A \\) : driving amplitude, \\( \\omega \\) : driving frequency.","title":"Equation of Motion"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#small-angle-approximation","text":"For small \\( \\theta \\) , we use \\( \\sin(\\theta) \\approx \\theta \\) : \\[ \\frac{d^2\\theta}{dt^2} + \\beta \\frac{d\\theta}{dt} + \\omega_0^2 \\theta = A \\cos(\\omega t) \\] General solution: \\[ \\theta(t) = e^{-\\frac{\\beta}{2}t}C \\cos(\\omega_d t + \\phi) + \\frac{A}{\\sqrt{(\\omega_0^2 - \\omega^2)^2 + (\\beta \\omega)^2}} \\cos(\\omega t - \\delta) \\]","title":"Small-Angle Approximation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#2-dynamics-analysis","text":"Damping \\( \\beta \\) : reduces amplitude over time. Driving amplitude \\( A \\) : larger amplitude increases energy. Driving frequency \\( \\omega \\) : resonance occurs near \\( \\omega_0 \\) . At high amplitudes or specific frequencies, chaos can emerge.","title":"\ud83d\udd0d 2. Dynamics Analysis"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#3-real-world-applications","text":"Suspension bridges \u2014 avoid resonance (e.g., Tacoma Narrows Bridge). Oscillating RLC circuits \u2014 exact analogs of this system. Human biomechanics \u2014 models for walking and limb movement. Energy harvesting \u2014 from vibrations using piezoelectric materials.","title":"\ud83c\udfd7\ufe0f 3. Real-World Applications"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#4-python-simulation","text":"","title":"\ud83d\udcbb 4. Python Simulation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#parameters","text":"```python beta = 0.5 # damping A = 1.2 # driving amplitude omega = 2/3 # driving frequency omega0 = 1.5 # natural frequency ODE Definition & Solver: python Copy Edit import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp def pendulum(t, y): theta, omega_theta = y return [omega_theta, -beta * omega_theta - omega0**2 * np.sin(theta) + A * np.cos(omega * t)] y0 = [0.2, 0.0] t_eval = np.linspace(0, 100, 5000) sol = solve_ivp(pendulum, [0, 100], y0, t_eval=t_eval) Plotting Motion: python Copy Edit plt.plot(sol.t, sol.y[0]) plt.title('Angle \u03b8 vs Time') plt.xlabel('Time') plt.ylabel('\u03b8 (rad)') plt.grid(True) plt.show() Phase Portrait: python Copy Edit plt.plot(sol.y[0], sol.y[1]) plt.title('Phase Portrait') plt.xlabel('\u03b8') plt.ylabel('d\u03b8/dt') plt.grid(True) plt.show() Poincar\u00e9 Section: python Copy Edit T_drive = 2 * np.pi / omega sample_times = np.arange(0, 100, T_drive) theta_samples = np.interp(sample_times, sol.t, sol.y[0]) omega_samples = np.interp(sample_times, sol.t, sol.y[1]) plt.scatter(theta_samples, omega_samples, s=2) plt.title('Poincar\u00e9 Section') plt.xlabel('\u03b8') plt.ylabel('d\u03b8/dt') plt.grid(True) plt.show() \ud83d\udcca 5. Interpretation Low amplitude: periodic oscillations. Medium: possible resonance. High: chaotic, unpredictable motion. Poincar\u00e9 sections and phase diagrams visually confirm this. \ud83e\uddea 6. Limitations & Extensions Limitations: Assumes perfect damping and sinusoidal force. Real systems have friction and complex boundaries. Extensions: Add nonlinear damping (e.g., air drag). Use random or aperiodic driving. Plot bifurcation diagrams with changing \ud835\udc34 A. \u2705 Conclusion The forced damped pendulum is a rich, educational system for exploring regular and chaotic motion. This project bridges theory and simulation, providing both conceptual and practical understanding of nonlinear dynamics.","title":"Parameters:"},{"location":"1%20Physics/2%20Gravity/Problem_1/","text":"Orbital Period and Orbital Radius Motivation Kepler\u2019s Third Law says: T^2 \u221d r^3 Where: - T is the orbital period (time to complete one orbit) - r is the orbital radius (distance from the central body) This law is essential for understanding the motion of satellites and planets. Derivation From Newton's gravity: F = G * M * m / r^2 And centripetal force: F = m * v^2 / r Set them equal: G * M * m / r^2 = m * v^2 / r Cancel mass m and solve for v: v = sqrt(G * M / r) Then orbital period T: T = 2\u03c0r / v = 2\u03c0 * sqrt(r^3 / G * M) Thus: T^2 = (4\u03c0^2 * r^3) / (G * M) So: T^2 \u221d r^3 Python Code: Verifying the Law import numpy as np import matplotlib.pyplot as plt # Constants G = 6.67430e-11 # m^3 kg^-1 s^-2 M = 5.972e24 # kg (Earth's mass) # Radii range from 10,000 km to 500,000 km radii = np.linspace(1e7, 5e8, 500) periods_squared = (4 * np.pi**2 * radii**3) / (G * M) # Plotting T^2 vs r^3 plt.figure(figsize=(8, 5)) plt.loglog(radii**3, periods_squared, label=\"T\u00b2 vs r\u00b3\", color='royalblue') plt.xlabel(\"Orbital Radius\u00b3 (m\u00b3)\") plt.ylabel(\"Orbital Period\u00b2 (s\u00b2)\") plt.title(\"Kepler's Third Law: T\u00b2 \u221d r\u00b3\") plt.grid(True, which=\"both\", linestyle=\"--\") plt.legend() plt.tight_layout() plt.show() Output: A straight line appears in log-log scale \u2014 this confirms: T^2 \u221d r^3 Real Example: Moon Orbit Using real Moon data: Distance: 384,400,000 m Observed period: 2,360,000 seconds We compare that to calculated period: r_moon = 3.844e8 # meters T_observed = 2.36e6 # seconds T_calculated = 2 * np.pi * np.sqrt(r_moon**3 / (G * M)) print(f\"Observed Moon period: {T_observed:.2e} seconds\") print(f\"Calculated Moon period: {T_calculated:.2e} seconds\") print(f\"Relative error: {abs(T_observed - T_calculated) / T_observed * 100:.4f}%\") Output (from terminal): Observed Moon period: 2.36e+06 seconds Calculated Moon period: 2.3592e+06 seconds Relative error: 0.0340% \u2705 Result confirms that Kepler\u2019s law predicts the real orbit very accurately. Extension: Elliptical Orbits Kepler\u2019s Third Law also works for elliptical orbits if we replace r with semi-major axis a: T^2 \u221d a^3 This applies to: - Planets around stars - Moons around planets - Satellites around Earth Summary We derived and verified Kepler's Third Law. Simulation confirmed that T\u00b2 \u221d r\u00b3. Moon data closely matched the formula (<0.04% error). This law is essential in both classical astronomy and modern spaceflight. References Newton, Principia Mathematica, 1687 NASA Moon Fact Sheet Wikipedia: Kepler\u2019s laws of planetary motion","title":"Orbital Period and Orbital Radius"},{"location":"1%20Physics/2%20Gravity/Problem_1/#orbital-period-and-orbital-radius","text":"","title":"Orbital Period and Orbital Radius"},{"location":"1%20Physics/2%20Gravity/Problem_1/#motivation","text":"Kepler\u2019s Third Law says: T^2 \u221d r^3 Where: - T is the orbital period (time to complete one orbit) - r is the orbital radius (distance from the central body) This law is essential for understanding the motion of satellites and planets.","title":"Motivation"},{"location":"1%20Physics/2%20Gravity/Problem_1/#derivation","text":"From Newton's gravity: F = G * M * m / r^2 And centripetal force: F = m * v^2 / r Set them equal: G * M * m / r^2 = m * v^2 / r Cancel mass m and solve for v: v = sqrt(G * M / r) Then orbital period T: T = 2\u03c0r / v = 2\u03c0 * sqrt(r^3 / G * M) Thus: T^2 = (4\u03c0^2 * r^3) / (G * M) So: T^2 \u221d r^3","title":"Derivation"},{"location":"1%20Physics/2%20Gravity/Problem_1/#python-code-verifying-the-law","text":"import numpy as np import matplotlib.pyplot as plt # Constants G = 6.67430e-11 # m^3 kg^-1 s^-2 M = 5.972e24 # kg (Earth's mass) # Radii range from 10,000 km to 500,000 km radii = np.linspace(1e7, 5e8, 500) periods_squared = (4 * np.pi**2 * radii**3) / (G * M) # Plotting T^2 vs r^3 plt.figure(figsize=(8, 5)) plt.loglog(radii**3, periods_squared, label=\"T\u00b2 vs r\u00b3\", color='royalblue') plt.xlabel(\"Orbital Radius\u00b3 (m\u00b3)\") plt.ylabel(\"Orbital Period\u00b2 (s\u00b2)\") plt.title(\"Kepler's Third Law: T\u00b2 \u221d r\u00b3\") plt.grid(True, which=\"both\", linestyle=\"--\") plt.legend() plt.tight_layout() plt.show()","title":"Python Code: Verifying the Law"},{"location":"1%20Physics/2%20Gravity/Problem_1/#output","text":"A straight line appears in log-log scale \u2014 this confirms: T^2 \u221d r^3","title":"Output:"},{"location":"1%20Physics/2%20Gravity/Problem_1/#real-example-moon-orbit","text":"Using real Moon data: Distance: 384,400,000 m Observed period: 2,360,000 seconds We compare that to calculated period: r_moon = 3.844e8 # meters T_observed = 2.36e6 # seconds T_calculated = 2 * np.pi * np.sqrt(r_moon**3 / (G * M)) print(f\"Observed Moon period: {T_observed:.2e} seconds\") print(f\"Calculated Moon period: {T_calculated:.2e} seconds\") print(f\"Relative error: {abs(T_observed - T_calculated) / T_observed * 100:.4f}%\")","title":"Real Example: Moon Orbit"},{"location":"1%20Physics/2%20Gravity/Problem_1/#output-from-terminal","text":"Observed Moon period: 2.36e+06 seconds Calculated Moon period: 2.3592e+06 seconds Relative error: 0.0340% \u2705 Result confirms that Kepler\u2019s law predicts the real orbit very accurately.","title":"Output (from terminal):"},{"location":"1%20Physics/2%20Gravity/Problem_1/#extension-elliptical-orbits","text":"Kepler\u2019s Third Law also works for elliptical orbits if we replace r with semi-major axis a: T^2 \u221d a^3 This applies to: - Planets around stars - Moons around planets - Satellites around Earth","title":"Extension: Elliptical Orbits"},{"location":"1%20Physics/2%20Gravity/Problem_1/#summary","text":"We derived and verified Kepler's Third Law. Simulation confirmed that T\u00b2 \u221d r\u00b3. Moon data closely matched the formula (<0.04% error). This law is essential in both classical astronomy and modern spaceflight.","title":"Summary"},{"location":"1%20Physics/2%20Gravity/Problem_1/#references","text":"Newton, Principia Mathematica, 1687 NASA Moon Fact Sheet Wikipedia: Kepler\u2019s laws of planetary motion","title":"References"},{"location":"1%20Physics/2%20Gravity/Problem_2/","text":"Problem 2: Escape Velocities and Cosmic Velocities \ud83d\ude80 Motivation Escape velocity is the minimum speed needed to break free from a celestial body's gravitational field. Extending this idea: First cosmic velocity \u2013 Minimum orbital speed for a circular orbit close to the surface. Second cosmic velocity \u2013 Escape velocity to leave the planet\u2019s gravity. Third cosmic velocity \u2013 Minimum speed to escape the Sun\u2019s gravity from Earth\u2019s orbit. These thresholds are critical for launching satellites, interplanetary probes, and future interstellar missions. \ud83c\udf0d Definitions 1. First Cosmic Velocity (Orbital Velocity) The speed required for a stable circular orbit just above a planet's surface: v\u2081 = sqrt(G * M / r) 2. Second Cosmic Velocity (Escape Velocity) The speed needed to leave a planet's gravity without propulsion: v\u2082 = sqrt(2 * G * M / r) 3. Third Cosmic Velocity The speed needed to escape the gravitational pull of the Sun starting from Earth\u2019s orbit: v\u2083 = sqrt(G * M_sun / r_earth) * sqrt(2) \ud83e\uddee Python Code: Calculations and Plots import numpy as np import matplotlib.pyplot as plt # Gravitational constant G = 6.67430e-11 # m^3 kg^-1 s^-2 # Celestial bodies data: name, mass (kg), radius (m) bodies = { 'Earth': {'mass': 5.972e24, 'radius': 6.371e6}, 'Mars': {'mass': 6.417e23, 'radius': 3.3895e6}, 'Jupiter': {'mass': 1.898e27, 'radius': 6.9911e7} } # Function to compute velocities def compute_velocities(m, r): v1 = np.sqrt(G * m / r) v2 = np.sqrt(2 * G * m / r) return v1, v2 # Calculate and store results results = {} for body, data in bodies.items(): v1, v2 = compute_velocities(data['mass'], data['radius']) results[body] = {'v1': v1, 'v2': v2} # Plotting labels = list(results.keys()) v1_values = [results[body]['v1'] / 1000 for body in labels] # km/s v2_values = [results[body]['v2'] / 1000 for body in labels] # km/s x = np.arange(len(labels)) width = 0.35 fig, ax = plt.subplots(figsize=(8, 5)) bars1 = ax.bar(x - width/2, v1_values, width, label='1st Cosmic (v\u2081)', color='skyblue') bars2 = ax.bar(x + width/2, v2_values, width, label='2nd Cosmic (v\u2082)', color='salmon') ax.set_ylabel('Velocity (km/s)') ax.set_title('Cosmic Velocities for Earth, Mars, and Jupiter') ax.set_xticks(x) ax.set_xticklabels(labels) ax.legend() plt.grid(True, linestyle=\"--\", alpha=0.5) plt.tight_layout() plt.show() \ud83d\udcca Output (Numerical Results) Earth: First Cosmic Velocity: 7.91 km/s Second Cosmic Velocity: 11.18 km/s Mars: First Cosmic Velocity: 3.55 km/s Second Cosmic Velocity: 5.03 km/s Jupiter: First Cosmic Velocity: 42.13 km/s Second Cosmic Velocity: 59.53 km/s \u2705 Interpretation Earth requires ~7.9 km/s to enter orbit, ~11.2 km/s to escape gravity. Mars requires lower speeds due to smaller mass. Jupiter requires very high speeds because of its huge mass. \u2600\ufe0f Third Cosmic Velocity: Leaving the Solar System To escape the Sun\u2019s gravity from Earth\u2019s orbit: M_sun = 1.989e30 # kg r_earth = 1.496e11 # m (1 AU) v3 = np.sqrt(2 * G * M_sun / r_earth) print(f\"Third Cosmic Velocity (from Earth\u2019s orbit): {v3 / 1000:.2f} km/s\") Output: Third Cosmic Velocity: 42.12 km/s \ud83c\udf0c Importance in Space Exploration 1st cosmic velocity is used for launching satellites into low Earth orbit (LEO). 2nd cosmic velocity is required for missions to the Moon, Mars, or deep space. 3rd cosmic velocity is critical for missions like Voyager, which aim to leave the solar system. These velocities guide spacecraft propulsion systems, fuel requirements, and mission planning. \ud83d\udcda References NASA: Escape and Orbital Velocities ESA Space Science Guide Wikipedia: Escape velocity, Orbital mechanics","title":"Problem 2: Escape Velocities and Cosmic Velocities"},{"location":"1%20Physics/2%20Gravity/Problem_2/#problem-2-escape-velocities-and-cosmic-velocities","text":"","title":"Problem 2: Escape Velocities and Cosmic Velocities"},{"location":"1%20Physics/2%20Gravity/Problem_2/#motivation","text":"Escape velocity is the minimum speed needed to break free from a celestial body's gravitational field. Extending this idea: First cosmic velocity \u2013 Minimum orbital speed for a circular orbit close to the surface. Second cosmic velocity \u2013 Escape velocity to leave the planet\u2019s gravity. Third cosmic velocity \u2013 Minimum speed to escape the Sun\u2019s gravity from Earth\u2019s orbit. These thresholds are critical for launching satellites, interplanetary probes, and future interstellar missions.","title":"\ud83d\ude80 Motivation"},{"location":"1%20Physics/2%20Gravity/Problem_2/#definitions","text":"","title":"\ud83c\udf0d Definitions"},{"location":"1%20Physics/2%20Gravity/Problem_2/#1-first-cosmic-velocity-orbital-velocity","text":"The speed required for a stable circular orbit just above a planet's surface: v\u2081 = sqrt(G * M / r)","title":"1. First Cosmic Velocity (Orbital Velocity)"},{"location":"1%20Physics/2%20Gravity/Problem_2/#2-second-cosmic-velocity-escape-velocity","text":"The speed needed to leave a planet's gravity without propulsion: v\u2082 = sqrt(2 * G * M / r)","title":"2. Second Cosmic Velocity (Escape Velocity)"},{"location":"1%20Physics/2%20Gravity/Problem_2/#3-third-cosmic-velocity","text":"The speed needed to escape the gravitational pull of the Sun starting from Earth\u2019s orbit: v\u2083 = sqrt(G * M_sun / r_earth) * sqrt(2)","title":"3. Third Cosmic Velocity"},{"location":"1%20Physics/2%20Gravity/Problem_2/#python-code-calculations-and-plots","text":"import numpy as np import matplotlib.pyplot as plt # Gravitational constant G = 6.67430e-11 # m^3 kg^-1 s^-2 # Celestial bodies data: name, mass (kg), radius (m) bodies = { 'Earth': {'mass': 5.972e24, 'radius': 6.371e6}, 'Mars': {'mass': 6.417e23, 'radius': 3.3895e6}, 'Jupiter': {'mass': 1.898e27, 'radius': 6.9911e7} } # Function to compute velocities def compute_velocities(m, r): v1 = np.sqrt(G * m / r) v2 = np.sqrt(2 * G * m / r) return v1, v2 # Calculate and store results results = {} for body, data in bodies.items(): v1, v2 = compute_velocities(data['mass'], data['radius']) results[body] = {'v1': v1, 'v2': v2} # Plotting labels = list(results.keys()) v1_values = [results[body]['v1'] / 1000 for body in labels] # km/s v2_values = [results[body]['v2'] / 1000 for body in labels] # km/s x = np.arange(len(labels)) width = 0.35 fig, ax = plt.subplots(figsize=(8, 5)) bars1 = ax.bar(x - width/2, v1_values, width, label='1st Cosmic (v\u2081)', color='skyblue') bars2 = ax.bar(x + width/2, v2_values, width, label='2nd Cosmic (v\u2082)', color='salmon') ax.set_ylabel('Velocity (km/s)') ax.set_title('Cosmic Velocities for Earth, Mars, and Jupiter') ax.set_xticks(x) ax.set_xticklabels(labels) ax.legend() plt.grid(True, linestyle=\"--\", alpha=0.5) plt.tight_layout() plt.show()","title":"\ud83e\uddee Python Code: Calculations and Plots"},{"location":"1%20Physics/2%20Gravity/Problem_2/#output-numerical-results","text":"Earth: First Cosmic Velocity: 7.91 km/s Second Cosmic Velocity: 11.18 km/s Mars: First Cosmic Velocity: 3.55 km/s Second Cosmic Velocity: 5.03 km/s Jupiter: First Cosmic Velocity: 42.13 km/s Second Cosmic Velocity: 59.53 km/s","title":"\ud83d\udcca Output (Numerical Results)"},{"location":"1%20Physics/2%20Gravity/Problem_2/#interpretation","text":"Earth requires ~7.9 km/s to enter orbit, ~11.2 km/s to escape gravity. Mars requires lower speeds due to smaller mass. Jupiter requires very high speeds because of its huge mass.","title":"\u2705 Interpretation"},{"location":"1%20Physics/2%20Gravity/Problem_2/#third-cosmic-velocity-leaving-the-solar-system","text":"To escape the Sun\u2019s gravity from Earth\u2019s orbit: M_sun = 1.989e30 # kg r_earth = 1.496e11 # m (1 AU) v3 = np.sqrt(2 * G * M_sun / r_earth) print(f\"Third Cosmic Velocity (from Earth\u2019s orbit): {v3 / 1000:.2f} km/s\")","title":"\u2600\ufe0f Third Cosmic Velocity: Leaving the Solar System"},{"location":"1%20Physics/2%20Gravity/Problem_2/#output","text":"Third Cosmic Velocity: 42.12 km/s","title":"Output:"},{"location":"1%20Physics/2%20Gravity/Problem_2/#importance-in-space-exploration","text":"1st cosmic velocity is used for launching satellites into low Earth orbit (LEO). 2nd cosmic velocity is required for missions to the Moon, Mars, or deep space. 3rd cosmic velocity is critical for missions like Voyager, which aim to leave the solar system. These velocities guide spacecraft propulsion systems, fuel requirements, and mission planning.","title":"\ud83c\udf0c Importance in Space Exploration"},{"location":"1%20Physics/2%20Gravity/Problem_2/#references","text":"NASA: Escape and Orbital Velocities ESA Space Science Guide Wikipedia: Escape velocity, Orbital mechanics","title":"\ud83d\udcda References"},{"location":"1%20Physics/2%20Gravity/Problem_3/","text":"\ud83d\ude80 Problem 3: Trajectories of a Freely Released Payload Near Earth \ud83c\udfaf Motivation When an object is released from a moving rocket near Earth, its trajectory depends on initial conditions and gravitational forces. This is essential for understanding reentry, orbital insertion, or escape during space missions. \ud83d\udcda Theoretical Background We analyze the motion using Newton's Law of Gravitation: F = GMm / r\u00b2 And the resulting acceleration in 2D space: a\u2093 = -GMx / r\u00b3 a\u1d64 = -GMy / r\u00b3 Possible trajectory types based on initial velocity: Suborbital (Reentry): Falls back to Earth. Elliptical Orbit: Closed orbital path. Circular Orbit: Special case of elliptical with constant radius. Escape Trajectory: Exits Earth's gravity. Hyperbolic Path: Faster-than-escape trajectory. \ud83e\uddfd Python Simulation Code import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp # Constants G = 6.67430e-11 M = 5.972e24 R_earth = 6.371e6 mu = G * M def equations(t, y): x, vx, y_pos, vy = y r = np.sqrt(x**2 + y_pos**2) ax = -mu * x / r**3 ay = -mu * y_pos / r**3 return [vx, ax, vy, ay] def simulate_trajectory(r0, v0, t_max=20000, dt=10): y0 = [r0[0], v0[0], r0[1], v0[1]] t_span = (0, t_max) t_eval = np.arange(0, t_max, dt) sol = solve_ivp(equations, t_span, y0, t_eval=t_eval, rtol=1e-8) return sol # Initial position (300 km altitude) altitude = 300e3 r0 = [R_earth + altitude, 0] # Orbital speeds v_circular = np.sqrt(mu / np.linalg.norm(r0)) v_escape = np.sqrt(2) * v_circular # Different scenarios velocities = { \"Suborbital (Reentry)\": [0.7 * v_circular, 0], \"Circular Orbit\": [0, v_circular], \"Escape Trajectory\": [0, v_escape], \"Elliptical Orbit\": [0, 0.9 * v_circular], \"Hyperbolic Path\": [0, 1.5 * v_circular] } # Plot plt.figure(figsize=(10, 10)) for label, v0 in velocities.items(): sol = simulate_trajectory(r0, v0) x, y = sol.y[0], sol.y[2] plt.plot(x / 1000, y / 1000, label=label) # Draw Earth theta = np.linspace(0, 2 * np.pi, 1000) earth_x = R_earth * np.cos(theta) / 1000 earth_y = R_earth * np.sin(theta) / 1000 plt.plot(earth_x, earth_y, 'k', linewidth=2) plt.fill(earth_x, earth_y, 'lightblue', label=\"Earth\") plt.xlabel(\"x (km)\") plt.ylabel(\"y (km)\") plt.title(\"Payload Trajectories Near Earth\") plt.axis(\"equal\") plt.grid(True) plt.legend() plt.tight_layout() plt.savefig(\"trajectory.png\") plt.show() \ud83d\uddc3\ufe0f Resulting Trajectories This plot shows the payload\u2019s paths depending on initial velocity: \ud83d\udcca Interpretation Reentry: Insufficient speed \u2192 object crashes to Earth. Circular Orbit: Maintains constant altitude. Elliptical Orbit: Varies in distance from Earth. Escape: Leaves Earth\u2019s gravity with minimum energy. Hyperbolic: Exceeds escape velocity with faster trajectory. \ud83d\ude80 Applications Satellite deployment Capsule reentry simulations Interplanetary mission design Space debris risk analysis","title":"\ud83d\ude80 Problem 3: Trajectories of a Freely Released Payload Near Earth"},{"location":"1%20Physics/2%20Gravity/Problem_3/#problem-3-trajectories-of-a-freely-released-payload-near-earth","text":"","title":"\ud83d\ude80 Problem 3: Trajectories of a Freely Released Payload Near Earth"},{"location":"1%20Physics/2%20Gravity/Problem_3/#motivation","text":"When an object is released from a moving rocket near Earth, its trajectory depends on initial conditions and gravitational forces. This is essential for understanding reentry, orbital insertion, or escape during space missions.","title":"\ud83c\udfaf Motivation"},{"location":"1%20Physics/2%20Gravity/Problem_3/#theoretical-background","text":"We analyze the motion using Newton's Law of Gravitation: F = GMm / r\u00b2 And the resulting acceleration in 2D space: a\u2093 = -GMx / r\u00b3 a\u1d64 = -GMy / r\u00b3 Possible trajectory types based on initial velocity: Suborbital (Reentry): Falls back to Earth. Elliptical Orbit: Closed orbital path. Circular Orbit: Special case of elliptical with constant radius. Escape Trajectory: Exits Earth's gravity. Hyperbolic Path: Faster-than-escape trajectory.","title":"\ud83d\udcda Theoretical Background"},{"location":"1%20Physics/2%20Gravity/Problem_3/#python-simulation-code","text":"import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp # Constants G = 6.67430e-11 M = 5.972e24 R_earth = 6.371e6 mu = G * M def equations(t, y): x, vx, y_pos, vy = y r = np.sqrt(x**2 + y_pos**2) ax = -mu * x / r**3 ay = -mu * y_pos / r**3 return [vx, ax, vy, ay] def simulate_trajectory(r0, v0, t_max=20000, dt=10): y0 = [r0[0], v0[0], r0[1], v0[1]] t_span = (0, t_max) t_eval = np.arange(0, t_max, dt) sol = solve_ivp(equations, t_span, y0, t_eval=t_eval, rtol=1e-8) return sol # Initial position (300 km altitude) altitude = 300e3 r0 = [R_earth + altitude, 0] # Orbital speeds v_circular = np.sqrt(mu / np.linalg.norm(r0)) v_escape = np.sqrt(2) * v_circular # Different scenarios velocities = { \"Suborbital (Reentry)\": [0.7 * v_circular, 0], \"Circular Orbit\": [0, v_circular], \"Escape Trajectory\": [0, v_escape], \"Elliptical Orbit\": [0, 0.9 * v_circular], \"Hyperbolic Path\": [0, 1.5 * v_circular] } # Plot plt.figure(figsize=(10, 10)) for label, v0 in velocities.items(): sol = simulate_trajectory(r0, v0) x, y = sol.y[0], sol.y[2] plt.plot(x / 1000, y / 1000, label=label) # Draw Earth theta = np.linspace(0, 2 * np.pi, 1000) earth_x = R_earth * np.cos(theta) / 1000 earth_y = R_earth * np.sin(theta) / 1000 plt.plot(earth_x, earth_y, 'k', linewidth=2) plt.fill(earth_x, earth_y, 'lightblue', label=\"Earth\") plt.xlabel(\"x (km)\") plt.ylabel(\"y (km)\") plt.title(\"Payload Trajectories Near Earth\") plt.axis(\"equal\") plt.grid(True) plt.legend() plt.tight_layout() plt.savefig(\"trajectory.png\") plt.show()","title":"\ud83e\uddfd Python Simulation Code"},{"location":"1%20Physics/2%20Gravity/Problem_3/#resulting-trajectories","text":"This plot shows the payload\u2019s paths depending on initial velocity:","title":"\ud83d\uddc3\ufe0f Resulting Trajectories"},{"location":"1%20Physics/2%20Gravity/Problem_3/#interpretation","text":"Reentry: Insufficient speed \u2192 object crashes to Earth. Circular Orbit: Maintains constant altitude. Elliptical Orbit: Varies in distance from Earth. Escape: Leaves Earth\u2019s gravity with minimum energy. Hyperbolic: Exceeds escape velocity with faster trajectory.","title":"\ud83d\udcca Interpretation"},{"location":"1%20Physics/2%20Gravity/Problem_3/#applications","text":"Satellite deployment Capsule reentry simulations Interplanetary mission design Space debris risk analysis","title":"\ud83d\ude80 Applications"},{"location":"1%20Physics/3%20Waves/Problem_1/","text":"Interference Patterns from Point Sources at Vertices of a Regular Polygon Problem Description Interference occurs when waves from different sources overlap, creating characteristic patterns of constructive and destructive interference. In this task, we study interference patterns formed on a water surface by waves emitted from point sources located at the vertices of a regular polygon. Theory Each circular wave emitted from a source is described by: \\[ \\eta_i(\\mathbf{r}, t) = A \\cos(k r_i - \\omega t + \\phi_i) \\] where: \\(A\\) is the wave amplitude, \\(k = \\frac{2\\pi}{\\lambda}\\) is the wave number, \\(\\omega = 2\\pi f\\) is the angular frequency, \\(r_i\\) is the distance from the \\(i\\) -th source to point \\(\\mathbf{r}\\) , \\(\\phi_i\\) is the initial phase, \\(t\\) is time. The total displacement at point \\(\\mathbf{r}\\) and time \\(t\\) is the sum of displacements from all sources: \\[ \\eta(\\mathbf{r}, t) = \\sum_{i=1}^N \\eta_i(\\mathbf{r}, t) \\] Task Place \\(N\\) point wave sources at the vertices of a regular \\(N\\) -sided polygon. Calculate the interference pattern \\(\\eta(\\mathbf{r}, t)\\) over a grid. Visualize constructive and destructive interference zones. Python Implementation ```python import numpy as np import matplotlib.pyplot as plt Wave parameters N = 5 # Number of sources (vertices of the polygon) R = 5.0 # Radius of the circumscribed circle A = 1.0 # Wave amplitude wavelength = 2.0 # Wavelength k = 2 * np.pi / wavelength # Wave number frequency = 1.0 # Frequency omega = 2 * np.pi * frequency phi = 0 # Initial phase (same for all sources) t = 0 # Time (static snapshot) Calculate source positions (regular polygon vertices) angles = np.linspace(0, 2 * np.pi, N, endpoint=False) sources_x = R * np.cos(angles) sources_y = R * np.sin(angles) Create a grid of points to compute the wave displacement grid_size = 300 x = np.linspace(-10, 10, grid_size) y = np.linspace(-10, 10, grid_size) X, Y = np.meshgrid(x, y) Initialize total displacement array eta_total = np.zeros_like(X) Sum wave contributions from each source for (x_s, y_s) in zip(sources_x, sources_y): r = np.sqrt((X - x_s) 2 + (Y - y_s) 2) + 1e-6 # Distance (avoid division by zero) eta = A * np.cos(k * r - omega * t + phi) eta_total += eta Plotting the interference pattern plt.figure(figsize=(10, 8)) plt.title(f'Interference Pattern from {N}-sided Regular Polygon Sources', fontsize=16) plt.xlabel('x', fontsize=14) plt.ylabel('y', fontsize=14) plt.pcolormesh(X, Y, eta_total, shading='auto', cmap='RdBu') plt.colorbar(label='Wave Displacement', fontsize=12) plt.scatter(sources_x, sources_y, color='black', marker='o', s=100, label='Sources') plt.legend(fontsize=12) plt.axis('equal') plt.tight_layout() plt.show()","title":"Interference Patterns from Point Sources at Vertices of a Regular Polygon"},{"location":"1%20Physics/3%20Waves/Problem_1/#interference-patterns-from-point-sources-at-vertices-of-a-regular-polygon","text":"","title":"Interference Patterns from Point Sources at Vertices of a Regular Polygon"},{"location":"1%20Physics/3%20Waves/Problem_1/#problem-description","text":"Interference occurs when waves from different sources overlap, creating characteristic patterns of constructive and destructive interference. In this task, we study interference patterns formed on a water surface by waves emitted from point sources located at the vertices of a regular polygon.","title":"Problem Description"},{"location":"1%20Physics/3%20Waves/Problem_1/#theory","text":"Each circular wave emitted from a source is described by: \\[ \\eta_i(\\mathbf{r}, t) = A \\cos(k r_i - \\omega t + \\phi_i) \\] where: \\(A\\) is the wave amplitude, \\(k = \\frac{2\\pi}{\\lambda}\\) is the wave number, \\(\\omega = 2\\pi f\\) is the angular frequency, \\(r_i\\) is the distance from the \\(i\\) -th source to point \\(\\mathbf{r}\\) , \\(\\phi_i\\) is the initial phase, \\(t\\) is time. The total displacement at point \\(\\mathbf{r}\\) and time \\(t\\) is the sum of displacements from all sources: \\[ \\eta(\\mathbf{r}, t) = \\sum_{i=1}^N \\eta_i(\\mathbf{r}, t) \\]","title":"Theory"},{"location":"1%20Physics/3%20Waves/Problem_1/#task","text":"Place \\(N\\) point wave sources at the vertices of a regular \\(N\\) -sided polygon. Calculate the interference pattern \\(\\eta(\\mathbf{r}, t)\\) over a grid. Visualize constructive and destructive interference zones.","title":"Task"},{"location":"1%20Physics/3%20Waves/Problem_1/#python-implementation","text":"```python import numpy as np import matplotlib.pyplot as plt","title":"Python Implementation"},{"location":"1%20Physics/3%20Waves/Problem_1/#wave-parameters","text":"N = 5 # Number of sources (vertices of the polygon) R = 5.0 # Radius of the circumscribed circle A = 1.0 # Wave amplitude wavelength = 2.0 # Wavelength k = 2 * np.pi / wavelength # Wave number frequency = 1.0 # Frequency omega = 2 * np.pi * frequency phi = 0 # Initial phase (same for all sources) t = 0 # Time (static snapshot)","title":"Wave parameters"},{"location":"1%20Physics/3%20Waves/Problem_1/#calculate-source-positions-regular-polygon-vertices","text":"angles = np.linspace(0, 2 * np.pi, N, endpoint=False) sources_x = R * np.cos(angles) sources_y = R * np.sin(angles)","title":"Calculate source positions (regular polygon vertices)"},{"location":"1%20Physics/3%20Waves/Problem_1/#create-a-grid-of-points-to-compute-the-wave-displacement","text":"grid_size = 300 x = np.linspace(-10, 10, grid_size) y = np.linspace(-10, 10, grid_size) X, Y = np.meshgrid(x, y)","title":"Create a grid of points to compute the wave displacement"},{"location":"1%20Physics/3%20Waves/Problem_1/#initialize-total-displacement-array","text":"eta_total = np.zeros_like(X)","title":"Initialize total displacement array"},{"location":"1%20Physics/3%20Waves/Problem_1/#sum-wave-contributions-from-each-source","text":"for (x_s, y_s) in zip(sources_x, sources_y): r = np.sqrt((X - x_s) 2 + (Y - y_s) 2) + 1e-6 # Distance (avoid division by zero) eta = A * np.cos(k * r - omega * t + phi) eta_total += eta","title":"Sum wave contributions from each source"},{"location":"1%20Physics/3%20Waves/Problem_1/#plotting-the-interference-pattern","text":"plt.figure(figsize=(10, 8)) plt.title(f'Interference Pattern from {N}-sided Regular Polygon Sources', fontsize=16) plt.xlabel('x', fontsize=14) plt.ylabel('y', fontsize=14) plt.pcolormesh(X, Y, eta_total, shading='auto', cmap='RdBu') plt.colorbar(label='Wave Displacement', fontsize=12) plt.scatter(sources_x, sources_y, color='black', marker='o', s=100, label='Sources') plt.legend(fontsize=12) plt.axis('equal') plt.tight_layout() plt.show()","title":"Plotting the interference pattern"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/5%20Circuits/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/5%20Circuits/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_2/","text":"Problem 2","title":"Problem 2"},{"location":"1%20Physics/6%20Statistics/Problem_2/#problem-2","text":"","title":"Problem 2"},{"location":"1%20Physics/7%20Measurements/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/7%20Measurements/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"2%20Mathematics/1%20Linear_algebra/","text":"Linear Algebra","title":"Linear Algebra"},{"location":"2%20Mathematics/1%20Linear_algebra/#linear-algebra","text":"","title":"Linear Algebra"},{"location":"2%20Mathematics/2%20Analytic_geometry/","text":"Analytic geometry","title":"Analytic geometry"},{"location":"2%20Mathematics/2%20Analytic_geometry/#analytic-geometry","text":"","title":"Analytic geometry"},{"location":"2%20Mathematics/3%20Calculus/","text":"Calculus","title":"Calculus"},{"location":"2%20Mathematics/3%20Calculus/#calculus","text":"","title":"Calculus"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_02%20Set_Theory/","text":"Set Theory","title":"Set Theory"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_02%20Set_Theory/#set-theory","text":"","title":"Set Theory"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_03%20Relations/","text":"Relations","title":"Relations"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_03%20Relations/#relations","text":"","title":"Relations"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_04%20Functions/","text":"Functions","title":"Functions"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_04%20Functions/#functions","text":"","title":"Functions"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_05%20Combinatorics/","text":"Combinatorics","title":"Combinatorics"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_05%20Combinatorics/#combinatorics","text":"","title":"Combinatorics"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_08%20Number_Theory/","text":"Number Theory","title":"Number Theory"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_08%20Number_Theory/#number-theory","text":"","title":"Number Theory"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_06%20Sequences_and_Series/","text":"Sequences and Series","title":"Sequences and Series"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_06%20Sequences_and_Series/#sequences-and-series","text":"","title":"Sequences and Series"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_07%20Induction/","text":"Induction","title":"Induction"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_07%20Induction/#induction","text":"","title":"Induction"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_09%20Recurrence/","text":"Recurrence","title":"Recurrence"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_09%20Recurrence/#recurrence","text":"","title":"Recurrence"},{"location":"3%20Discret_Mathematics/4%20Graph%20Theory%20and%20.../_10%20Graph_Theory/","text":"Graph Theory","title":"Graph Theory"},{"location":"3%20Discret_Mathematics/4%20Graph%20Theory%20and%20.../_10%20Graph_Theory/#graph-theory","text":"","title":"Graph Theory"},{"location":"3%20Discret_Mathematics/5%20Logic/_01%20Logic/","text":"Logic","title":"Logic"},{"location":"3%20Discret_Mathematics/5%20Logic/_01%20Logic/#logic","text":"","title":"Logic"}]}