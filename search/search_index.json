{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Introduction Technical setup Install Visual Studio Code from here Install folowing extensions in Visual Studio Code: Github Repositories (GitHub, Inc.) GitHub Copilot (GitHub Copilot) GitHub Actions (GitHub, Inc.) Python (Microsoft) Useful links Python Miniconda Documentation Google Colab How to use this repository Below are the steps you need to follow: Create a GitHub account if you don\u2019t have one. Fork this repository to your account. Enable the Issues tab: Go to the Settings tab and check the Issues option. Add your professor as a collaborator: Go to the Settings tab and add their GitHub username in the Collaborators section. Install python: Download Source Code & WWW GitHub repo WWW Where can I find the problems? Please visit the Mathematics Physics Lectures website. Physics Mathematics Discret Mathematics","title":"Introduction"},{"location":"#introduction","text":"","title":"Introduction"},{"location":"#technical-setup","text":"Install Visual Studio Code from here Install folowing extensions in Visual Studio Code: Github Repositories (GitHub, Inc.) GitHub Copilot (GitHub Copilot) GitHub Actions (GitHub, Inc.) Python (Microsoft)","title":"Technical setup"},{"location":"#useful-links","text":"Python Miniconda Documentation Google Colab","title":"Useful links"},{"location":"#how-to-use-this-repository","text":"Below are the steps you need to follow: Create a GitHub account if you don\u2019t have one. Fork this repository to your account. Enable the Issues tab: Go to the Settings tab and check the Issues option. Add your professor as a collaborator: Go to the Settings tab and add their GitHub username in the Collaborators section. Install python: Download Source Code & WWW GitHub repo WWW","title":"How to use this repository"},{"location":"#where-can-i-find-the-problems","text":"Please visit the Mathematics Physics Lectures website. Physics Mathematics Discret Mathematics","title":"Where can I find the problems?"},{"location":"to%20do%20/","text":"","title":"To do "},{"location":"1%20Physics/1%20Mechanics/Problem_1/","text":"Problem 1 Sure! Here's a simple solution analyzing how the range of a projectile depends on the angle of projection. Step 1: Define the Range Formula For a projectile launched with an initial velocity \\( v_0 \\) at an angle \\( \\theta \\) (assuming launch and landing at the same height), the range \\( R \\) is given by: \\[ R = \\frac{v_0^2 \\sin(2\\theta)}{g} \\] where: \\( v_0 \\) is the initial velocity, \\( g \\) is the acceleration due to gravity (\u2248 9.81 m/s\u00b2), \\( \\theta \\) is the launch angle. Step 2: Analyze the Relationship The function \\( R = \\sin(2\\theta) \\) suggests that the range depends on the sine of twice the angle. The maximum value of \\( \\sin(2\\theta) \\) is 1, which occurs at \\( 2\\theta = 90^\\circ \\) , meaning the maximum range happens at \\( \\theta = 45^\\circ \\) . Step 3: Special Cases \\( \\theta = 0^\\circ \\) or \\( \\theta = 90^\\circ \\) : \\( R = 0 \\) (no horizontal displacement). \\( \\theta = 45^\\circ \\) : Maximum range. Step 4: Visualization (Optional) A simple Python plot using Matplotlib can help visualize the range function: import numpy as np import matplotlib.pyplot as plt g = 9.81 # Gravity (m/s^2) v0 = 10 # Initial velocity (m/s) angles = np.linspace(0, 90, 100) # Angle from 0 to 90 degrees radians = np.radians(angles) # Convert to radians ranges = (v0**2 * np.sin(2 * radians)) / g # Compute range plt.plot(angles, ranges) plt.xlabel(\"Launch Angle (degrees)\") plt.ylabel(\"Range (m)\") plt.title(\"Projectile Range vs. Launch Angle\") plt.grid() plt.show() Conclusion The range is symmetrical around \\( 45^\\circ \\) . The maximum range occurs at \\( 45^\\circ \\) . The function follows a sine wave pattern based on \\( \\sin(2\\theta) \\) . Would you like a more detailed breakdown or a different approach? \ud83d\ude80","title":"Problem 1"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#problem-1","text":"Sure! Here's a simple solution analyzing how the range of a projectile depends on the angle of projection.","title":"Problem 1"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#step-1-define-the-range-formula","text":"For a projectile launched with an initial velocity \\( v_0 \\) at an angle \\( \\theta \\) (assuming launch and landing at the same height), the range \\( R \\) is given by: \\[ R = \\frac{v_0^2 \\sin(2\\theta)}{g} \\] where: \\( v_0 \\) is the initial velocity, \\( g \\) is the acceleration due to gravity (\u2248 9.81 m/s\u00b2), \\( \\theta \\) is the launch angle.","title":"Step 1: Define the Range Formula"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#step-2-analyze-the-relationship","text":"The function \\( R = \\sin(2\\theta) \\) suggests that the range depends on the sine of twice the angle. The maximum value of \\( \\sin(2\\theta) \\) is 1, which occurs at \\( 2\\theta = 90^\\circ \\) , meaning the maximum range happens at \\( \\theta = 45^\\circ \\) .","title":"Step 2: Analyze the Relationship"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#step-3-special-cases","text":"\\( \\theta = 0^\\circ \\) or \\( \\theta = 90^\\circ \\) : \\( R = 0 \\) (no horizontal displacement). \\( \\theta = 45^\\circ \\) : Maximum range.","title":"Step 3: Special Cases"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#step-4-visualization-optional","text":"A simple Python plot using Matplotlib can help visualize the range function: import numpy as np import matplotlib.pyplot as plt g = 9.81 # Gravity (m/s^2) v0 = 10 # Initial velocity (m/s) angles = np.linspace(0, 90, 100) # Angle from 0 to 90 degrees radians = np.radians(angles) # Convert to radians ranges = (v0**2 * np.sin(2 * radians)) / g # Compute range plt.plot(angles, ranges) plt.xlabel(\"Launch Angle (degrees)\") plt.ylabel(\"Range (m)\") plt.title(\"Projectile Range vs. Launch Angle\") plt.grid() plt.show()","title":"Step 4: Visualization (Optional)"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#conclusion","text":"The range is symmetrical around \\( 45^\\circ \\) . The maximum range occurs at \\( 45^\\circ \\) . The function follows a sine wave pattern based on \\( \\sin(2\\theta) \\) . Would you like a more detailed breakdown or a different approach? \ud83d\ude80","title":"Conclusion"},{"location":"1%20Physics/1%20Mechanics/Problem_2/","text":"Investigating the Dynamics of a Forced Damped Pendulum \ud83c\udfaf Motivation The forced damped pendulum is a classic nonlinear system exhibiting rich behavior\u2014from simple oscillations to chaos. Understanding this system allows us to explore mechanical resonance, nonlinear dynamics, and real-world systems like suspension bridges and electrical circuits. \ud83d\udcd8 1. Theoretical Background Equation of Motion \\[ \\frac{d^2\\theta}{dt^2} + \\beta \\frac{d\\theta}{dt} + \\omega_0^2 \\sin(\\theta) = A \\cos(\\omega t) \\] Where: \\( \\theta(t) \\) : angle, \\( \\beta \\) : damping coefficient, \\( \\omega_0 \\) : natural frequency, \\( A \\) : driving amplitude, \\( \\omega \\) : driving frequency. Small-Angle Approximation For small \\( \\theta \\) , we use \\( \\sin(\\theta) \\approx \\theta \\) : \\[ \\frac{d^2\\theta}{dt^2} + \\beta \\frac{d\\theta}{dt} + \\omega_0^2 \\theta = A \\cos(\\omega t) \\] General solution: \\[ \\theta(t) = e^{-\\frac{\\beta}{2}t}C \\cos(\\omega_d t + \\phi) + \\frac{A}{\\sqrt{(\\omega_0^2 - \\omega^2)^2 + (\\beta \\omega)^2}} \\cos(\\omega t - \\delta) \\] \ud83d\udd0d 2. Dynamics Analysis Damping \\( \\beta \\) : reduces amplitude over time. Driving amplitude \\( A \\) : larger amplitude increases energy. Driving frequency \\( \\omega \\) : resonance occurs near \\( \\omega_0 \\) . At high amplitudes or specific frequencies, chaos can emerge. \ud83c\udfd7\ufe0f 3. Real-World Applications Suspension bridges \u2014 avoid resonance (e.g., Tacoma Narrows Bridge). Oscillating RLC circuits \u2014 exact analogs of this system. Human biomechanics \u2014 models for walking and limb movement. Energy harvesting \u2014 from vibrations using piezoelectric materials. \ud83d\udcbb 4. Python Simulation Parameters: ```python beta = 0.5 # damping A = 1.2 # driving amplitude omega = 2/3 # driving frequency omega0 = 1.5 # natural frequency ODE Definition & Solver: python Copy Edit import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp def pendulum(t, y): theta, omega_theta = y return [omega_theta, -beta * omega_theta - omega0**2 * np.sin(theta) + A * np.cos(omega * t)] y0 = [0.2, 0.0] t_eval = np.linspace(0, 100, 5000) sol = solve_ivp(pendulum, [0, 100], y0, t_eval=t_eval) Plotting Motion: python Copy Edit plt.plot(sol.t, sol.y[0]) plt.title('Angle \u03b8 vs Time') plt.xlabel('Time') plt.ylabel('\u03b8 (rad)') plt.grid(True) plt.show() Phase Portrait: python Copy Edit plt.plot(sol.y[0], sol.y[1]) plt.title('Phase Portrait') plt.xlabel('\u03b8') plt.ylabel('d\u03b8/dt') plt.grid(True) plt.show() Poincar\u00e9 Section: python Copy Edit T_drive = 2 * np.pi / omega sample_times = np.arange(0, 100, T_drive) theta_samples = np.interp(sample_times, sol.t, sol.y[0]) omega_samples = np.interp(sample_times, sol.t, sol.y[1]) plt.scatter(theta_samples, omega_samples, s=2) plt.title('Poincar\u00e9 Section') plt.xlabel('\u03b8') plt.ylabel('d\u03b8/dt') plt.grid(True) plt.show() \ud83d\udcca 5. Interpretation Low amplitude: periodic oscillations. Medium: possible resonance. High: chaotic, unpredictable motion. Poincar\u00e9 sections and phase diagrams visually confirm this. \ud83e\uddea 6. Limitations & Extensions Limitations: Assumes perfect damping and sinusoidal force. Real systems have friction and complex boundaries. Extensions: Add nonlinear damping (e.g., air drag). Use random or aperiodic driving. Plot bifurcation diagrams with changing \ud835\udc34 A. \u2705 Conclusion The forced damped pendulum is a rich, educational system for exploring regular and chaotic motion. This project bridges theory and simulation, providing both conceptual and practical understanding of nonlinear dynamics.","title":"Investigating the Dynamics of a Forced Damped Pendulum"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#investigating-the-dynamics-of-a-forced-damped-pendulum","text":"","title":"Investigating the Dynamics of a Forced Damped Pendulum"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#motivation","text":"The forced damped pendulum is a classic nonlinear system exhibiting rich behavior\u2014from simple oscillations to chaos. Understanding this system allows us to explore mechanical resonance, nonlinear dynamics, and real-world systems like suspension bridges and electrical circuits.","title":"\ud83c\udfaf Motivation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#1-theoretical-background","text":"","title":"\ud83d\udcd8 1. Theoretical Background"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#equation-of-motion","text":"\\[ \\frac{d^2\\theta}{dt^2} + \\beta \\frac{d\\theta}{dt} + \\omega_0^2 \\sin(\\theta) = A \\cos(\\omega t) \\] Where: \\( \\theta(t) \\) : angle, \\( \\beta \\) : damping coefficient, \\( \\omega_0 \\) : natural frequency, \\( A \\) : driving amplitude, \\( \\omega \\) : driving frequency.","title":"Equation of Motion"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#small-angle-approximation","text":"For small \\( \\theta \\) , we use \\( \\sin(\\theta) \\approx \\theta \\) : \\[ \\frac{d^2\\theta}{dt^2} + \\beta \\frac{d\\theta}{dt} + \\omega_0^2 \\theta = A \\cos(\\omega t) \\] General solution: \\[ \\theta(t) = e^{-\\frac{\\beta}{2}t}C \\cos(\\omega_d t + \\phi) + \\frac{A}{\\sqrt{(\\omega_0^2 - \\omega^2)^2 + (\\beta \\omega)^2}} \\cos(\\omega t - \\delta) \\]","title":"Small-Angle Approximation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#2-dynamics-analysis","text":"Damping \\( \\beta \\) : reduces amplitude over time. Driving amplitude \\( A \\) : larger amplitude increases energy. Driving frequency \\( \\omega \\) : resonance occurs near \\( \\omega_0 \\) . At high amplitudes or specific frequencies, chaos can emerge.","title":"\ud83d\udd0d 2. Dynamics Analysis"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#3-real-world-applications","text":"Suspension bridges \u2014 avoid resonance (e.g., Tacoma Narrows Bridge). Oscillating RLC circuits \u2014 exact analogs of this system. Human biomechanics \u2014 models for walking and limb movement. Energy harvesting \u2014 from vibrations using piezoelectric materials.","title":"\ud83c\udfd7\ufe0f 3. Real-World Applications"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#4-python-simulation","text":"","title":"\ud83d\udcbb 4. Python Simulation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#parameters","text":"```python beta = 0.5 # damping A = 1.2 # driving amplitude omega = 2/3 # driving frequency omega0 = 1.5 # natural frequency ODE Definition & Solver: python Copy Edit import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp def pendulum(t, y): theta, omega_theta = y return [omega_theta, -beta * omega_theta - omega0**2 * np.sin(theta) + A * np.cos(omega * t)] y0 = [0.2, 0.0] t_eval = np.linspace(0, 100, 5000) sol = solve_ivp(pendulum, [0, 100], y0, t_eval=t_eval) Plotting Motion: python Copy Edit plt.plot(sol.t, sol.y[0]) plt.title('Angle \u03b8 vs Time') plt.xlabel('Time') plt.ylabel('\u03b8 (rad)') plt.grid(True) plt.show() Phase Portrait: python Copy Edit plt.plot(sol.y[0], sol.y[1]) plt.title('Phase Portrait') plt.xlabel('\u03b8') plt.ylabel('d\u03b8/dt') plt.grid(True) plt.show() Poincar\u00e9 Section: python Copy Edit T_drive = 2 * np.pi / omega sample_times = np.arange(0, 100, T_drive) theta_samples = np.interp(sample_times, sol.t, sol.y[0]) omega_samples = np.interp(sample_times, sol.t, sol.y[1]) plt.scatter(theta_samples, omega_samples, s=2) plt.title('Poincar\u00e9 Section') plt.xlabel('\u03b8') plt.ylabel('d\u03b8/dt') plt.grid(True) plt.show() \ud83d\udcca 5. Interpretation Low amplitude: periodic oscillations. Medium: possible resonance. High: chaotic, unpredictable motion. Poincar\u00e9 sections and phase diagrams visually confirm this. \ud83e\uddea 6. Limitations & Extensions Limitations: Assumes perfect damping and sinusoidal force. Real systems have friction and complex boundaries. Extensions: Add nonlinear damping (e.g., air drag). Use random or aperiodic driving. Plot bifurcation diagrams with changing \ud835\udc34 A. \u2705 Conclusion The forced damped pendulum is a rich, educational system for exploring regular and chaotic motion. This project bridges theory and simulation, providing both conceptual and practical understanding of nonlinear dynamics.","title":"Parameters:"},{"location":"1%20Physics/2%20Gravity/Problem_1/","text":"Orbital Period and Orbital Radius: Kepler's Third Law in Practice \ud83c\udf0c Motivation Kepler's Third Law reveals the elegant relationship between a planet's orbital period and its distance from the body it orbits. This law provides critical insight into the structure and behavior of planetary systems, allowing astronomers to estimate masses, distances, and even discover exoplanets. It forms a bridge between Newtonian gravity and observed celestial motions. \ud83d\udd0d 1. Derivation: Kepler's Third Law for Circular Orbits Newton's Law of Gravitation: Centripetal Force for Circular Motion: Equating gravitational force and centripetal force: Orbital period : Substitute into the velocity equation: Rearranged: Final Form (Kepler's Third Law): \ud83d\udcad 2. Implications in Astronomy Allows calculation of planetary distances when periods are known. Estimating masses of stars or planets from satellite motion. Used in orbital mechanics to plan space missions. Example: Earth's orbit year, AU Any other body in the solar system follows: \ud83c\udf0d 3. Real-World Examples Moon Around Earth: Orbital radius m Period days Using Kepler's law, we can estimate Earth's mass or verify the law with actual data. Planets in the Solar System: Planet Radius (AU) Period (Years) T^2 / r^3 Mercury 0.39 0.24 1.01 Venus 0.72 0.62 1.01 Earth 1.00 1.00 1.00 Mars 1.52 1.88 1.01 Jupiter 5.20 11.86 1.00 \ud83d\udcc8 4. Python Simulation of Circular Orbits import numpy as np import matplotlib.pyplot as plt G = 6.67430e-11 # gravitational constant M = 5.972e24 # mass of Earth (kg) radii = np.linspace(1e7, 5e8, 100) periods = 2 * np.pi * np.sqrt(radii**3 / (G * M)) plt.plot(radii / 1e6, periods / 3600, label='T vs r (Earth orbit)') plt.xlabel('Orbital Radius (10^6 m)') plt.ylabel('Orbital Period (hours)') plt.title('Orbital Period vs Radius') plt.grid(True) plt.legend() plt.show() Verification of Kepler's Law: T2 = periods 2 r3 = radii 3 plt.plot(r3, T2) plt.xlabel('r^3') plt.ylabel('T^2') plt.title(\"Kepler's Third Law: T^2 vs r^3\") plt.grid(True) plt.show() \ud83d\udd04 5. Extensions to Elliptical Orbits For elliptical orbits, is replaced by the semi-major axis . Kepler's Law still holds: Applies to comets, asteroids, and binary stars. Used to determine masses of galaxies and detect exoplanets. \u2705 Conclusion Kepler's Third Law elegantly connects time and space for orbiting bodies. From understanding planetary motion to designing satellite systems, the relationship is fundamental. Through derivation, application, and simulation, this project confirms the law and shows its profound relevance across astronomy and physics.","title":"Problem 1"},{"location":"1%20Physics/2%20Gravity/Problem_2/","text":"Problem 2 Escape Velocities and Cosmic Velocities \ud83c\udf0c \ud83d\udcd8 Motivation Escape velocity determines the minimum speed required to break free from a celestial body's gravity. This idea leads to the first , second , and third cosmic velocities \u2014 critical for understanding orbits, escapes, and interplanetary missions. \ud83d\ude80 Definitions First Cosmic Velocity \u2014 Orbital velocity: speed needed to stay in a circular orbit close to the planet's surface. Second Cosmic Velocity \u2014 Escape velocity: speed needed to leave the planet's gravitational field entirely. Third Cosmic Velocity \u2014 Interplanetary escape velocity: speed needed to leave the Solar System from Earth. \ud83d\udcd0 Mathematical Derivations 1. First Cosmic Velocity \\( v_1 \\) \\[ v_1 = \\sqrt{\\frac{G M}{R}} \\] Where: - \\( G \\) = gravitational constant - \\( M \\) = mass of the planet - \\( R \\) = radius of the planet 2. Second Cosmic Velocity (Escape Velocity) \\( v_2 \\) \\[ v_2 = \\sqrt{2} \\cdot v_1 = \\sqrt{\\frac{2GM}{R}} \\] 3. Third Cosmic Velocity \\( v_3 \\) Approximated from Earth's orbit around the Sun: \\[ v_3 = \\sqrt{2} \\cdot v_{\\text{earth orbit}} \\approx 42.1 \\, \\text{km/s} \\] \ud83c\udf0d Celestial Body Parameters We'll compare Earth, Mars, and Jupiter. Body Mass (kg) Radius (m) Earth 5.972\u00d710\u00b2\u2074 6.371\u00d710\u2076 Mars 6.417\u00d710\u00b2\u00b3 3.390\u00d710\u2076 Jupiter 1.898\u00d710\u00b2\u2077 6.991\u00d710\u2077 \ud83e\uddea Python Simulation ```python import numpy as np import matplotlib.pyplot as plt Gravitational constant G = 6.67430e-11 # m^3/kg/s^2 Celestial bodies: name, mass (kg), radius (m) bodies = { \"Earth\": (5.972e24, 6.371e6), \"Mars\": (6.417e23, 3.390e6), \"Jupiter\": (1.898e27, 6.991e7), } Store results names, v1s, v2s = [], [], [] for name, (M, R) in bodies.items(): v1 = np.sqrt(G * M / R) / 1000 # First cosmic velocity [km/s] v2 = np.sqrt(2 * G * M / R) / 1000 # Second cosmic velocity [km/s] names.append(name) v1s.append(v1) v2s.append(v2) Plot x = np.arange(len(names)) width = 0.35 plt.figure(figsize=(8, 5)) plt.bar(x - width/2, v1s, width, label='1st Cosmic Velocity') plt.bar(x + width/2, v2s, width, label='2nd Cosmic Velocity') plt.xticks(x, names) plt.ylabel(\"Velocity (km/s)\") plt.title(\"Cosmic Velocities of Planets\") plt.legend() plt.grid(True, axis='y') plt.tight_layout() plt.show() import numpy as np G = 6.67430e-11 # gravitational constant [m^3 kg^-1 s^-2] M_sun = 1.989e30 # mass of the Sun [kg] R_earth_sun = 1.496e11 # average Earth-Sun distance [m] v3 = np.sqrt(2 * G * M_sun / R_earth_sun) / 1000 # [km/s] print(f\"Third Cosmic Velocity (from Earth orbit): {v3:.2f} km/s\") Third Cosmic Velocity (from Earth orbit): 42.12 km/s","title":"Problem 2"},{"location":"1%20Physics/2%20Gravity/Problem_2/#problem-2","text":"","title":"Problem 2"},{"location":"1%20Physics/2%20Gravity/Problem_2/#escape-velocities-and-cosmic-velocities","text":"","title":"Escape Velocities and Cosmic Velocities \ud83c\udf0c"},{"location":"1%20Physics/2%20Gravity/Problem_2/#motivation","text":"Escape velocity determines the minimum speed required to break free from a celestial body's gravity. This idea leads to the first , second , and third cosmic velocities \u2014 critical for understanding orbits, escapes, and interplanetary missions.","title":"\ud83d\udcd8 Motivation"},{"location":"1%20Physics/2%20Gravity/Problem_2/#definitions","text":"First Cosmic Velocity \u2014 Orbital velocity: speed needed to stay in a circular orbit close to the planet's surface. Second Cosmic Velocity \u2014 Escape velocity: speed needed to leave the planet's gravitational field entirely. Third Cosmic Velocity \u2014 Interplanetary escape velocity: speed needed to leave the Solar System from Earth.","title":"\ud83d\ude80 Definitions"},{"location":"1%20Physics/2%20Gravity/Problem_2/#mathematical-derivations","text":"","title":"\ud83d\udcd0 Mathematical Derivations"},{"location":"1%20Physics/2%20Gravity/Problem_2/#1-first-cosmic-velocity-v_1","text":"\\[ v_1 = \\sqrt{\\frac{G M}{R}} \\] Where: - \\( G \\) = gravitational constant - \\( M \\) = mass of the planet - \\( R \\) = radius of the planet","title":"1. First Cosmic Velocity \\( v_1 \\)"},{"location":"1%20Physics/2%20Gravity/Problem_2/#2-second-cosmic-velocity-escape-velocity-v_2","text":"\\[ v_2 = \\sqrt{2} \\cdot v_1 = \\sqrt{\\frac{2GM}{R}} \\]","title":"2. Second Cosmic Velocity (Escape Velocity) \\( v_2 \\)"},{"location":"1%20Physics/2%20Gravity/Problem_2/#3-third-cosmic-velocity-v_3","text":"Approximated from Earth's orbit around the Sun: \\[ v_3 = \\sqrt{2} \\cdot v_{\\text{earth orbit}} \\approx 42.1 \\, \\text{km/s} \\]","title":"3. Third Cosmic Velocity \\( v_3 \\)"},{"location":"1%20Physics/2%20Gravity/Problem_2/#celestial-body-parameters","text":"We'll compare Earth, Mars, and Jupiter. Body Mass (kg) Radius (m) Earth 5.972\u00d710\u00b2\u2074 6.371\u00d710\u2076 Mars 6.417\u00d710\u00b2\u00b3 3.390\u00d710\u2076 Jupiter 1.898\u00d710\u00b2\u2077 6.991\u00d710\u2077","title":"\ud83c\udf0d Celestial Body Parameters"},{"location":"1%20Physics/2%20Gravity/Problem_2/#python-simulation","text":"```python import numpy as np import matplotlib.pyplot as plt","title":"\ud83e\uddea Python Simulation"},{"location":"1%20Physics/2%20Gravity/Problem_2/#gravitational-constant","text":"G = 6.67430e-11 # m^3/kg/s^2","title":"Gravitational constant"},{"location":"1%20Physics/2%20Gravity/Problem_2/#celestial-bodies-name-mass-kg-radius-m","text":"bodies = { \"Earth\": (5.972e24, 6.371e6), \"Mars\": (6.417e23, 3.390e6), \"Jupiter\": (1.898e27, 6.991e7), }","title":"Celestial bodies: name, mass (kg), radius (m)"},{"location":"1%20Physics/2%20Gravity/Problem_2/#store-results","text":"names, v1s, v2s = [], [], [] for name, (M, R) in bodies.items(): v1 = np.sqrt(G * M / R) / 1000 # First cosmic velocity [km/s] v2 = np.sqrt(2 * G * M / R) / 1000 # Second cosmic velocity [km/s] names.append(name) v1s.append(v1) v2s.append(v2)","title":"Store results"},{"location":"1%20Physics/2%20Gravity/Problem_2/#plot","text":"x = np.arange(len(names)) width = 0.35 plt.figure(figsize=(8, 5)) plt.bar(x - width/2, v1s, width, label='1st Cosmic Velocity') plt.bar(x + width/2, v2s, width, label='2nd Cosmic Velocity') plt.xticks(x, names) plt.ylabel(\"Velocity (km/s)\") plt.title(\"Cosmic Velocities of Planets\") plt.legend() plt.grid(True, axis='y') plt.tight_layout() plt.show() import numpy as np G = 6.67430e-11 # gravitational constant [m^3 kg^-1 s^-2] M_sun = 1.989e30 # mass of the Sun [kg] R_earth_sun = 1.496e11 # average Earth-Sun distance [m] v3 = np.sqrt(2 * G * M_sun / R_earth_sun) / 1000 # [km/s] print(f\"Third Cosmic Velocity (from Earth orbit): {v3:.2f} km/s\") Third Cosmic Velocity (from Earth orbit): 42.12 km/s","title":"Plot"},{"location":"1%20Physics/2%20Gravity/Problem_3/","text":"Trajectories of a Freely Released Payload Near Earth body { font-family: Arial, sans-serif; margin: 40px; background-color: #f8f9fa; color: #333; line-height: 1.6; } h1, h2 { color: #2c3e50; } code { background: #e9ecef; padding: 2px 4px; border-radius: 4px; font-size: 90%; } pre { background-color: #e9ecef; padding: 10px; border-radius: 6px; overflow-x: auto; } Trajectories of a Freely Released Payload Near Earth 1. Motivation When a payload is released from a moving spacecraft in Earth\u2019s vicinity, the resulting path depends on the velocity vector at the moment of release. These trajectories\u2014elliptical, parabolic, or hyperbolic\u2014determine whether the object enters orbit, reenters Earth\u2019s atmosphere, or escapes Earth\u2019s gravity. Understanding these dynamics is crucial in mission planning for satellites, space stations, and deep-space probes. 2. Physical and Mathematical Background Newton's Law of Universal Gravitation: F = G * M * m / r\u00b2 Gravitational Acceleration: \u20d7a = -GM * \u20d7r / |r|\u00b3 G: Gravitational constant \u2248 6.674 \u00d7 10\u207b\u00b9\u00b9 Nm\u00b2/kg\u00b2 M: Mass of Earth \u2248 5.972 \u00d7 10\u00b2\u2074 kg r: Distance from Earth's center Total Specific Mechanical Energy: \u03b5 = v\u00b2/2 \u2212 GM/r \u03b5 < 0: Elliptical \u03b5 = 0: Parabolic \u03b5 > 0: Hyperbolic 3. Numerical Simulation of Payload Trajectories Python Simulation: import numpy as np import matplotlib.pyplot as plt # Constants G = 6.67430e-11 # m^3/kg/s^2 M_earth = 5.972e24 # kg R_earth = 6.371e6 # m # Function to calculate acceleration def acceleration(r): norm_r = np.linalg.norm(r) return -G * M_earth * r / norm_r**3 # Euler's method for orbital trajectory def simulate_trajectory(r0, v0, dt=1, t_max=10000): r = r0 v = v0 positions = [r.copy()] for _ in range(int(t_max / dt)): a = acceleration(r) v += a * dt r += v * dt positions.append(r.copy()) if np.linalg.norm(r) < R_earth: break return np.array(positions) # Initial conditions altitude = 400e3 # 400 km r0 = np.array([R_earth + altitude, 0]) v_circular = np.sqrt(G * M_earth / np.linalg.norm(r0)) # Try different velocities velocity_cases = [ (\"Suborbital\", v_circular * 0.9), (\"Circular Orbit\", v_circular), (\"Elliptical Orbit\", v_circular * 1.1), (\"Escape\", np.sqrt(2) * v_circular) ] plt.figure(figsize=(10, 10)) theta = np.linspace(0, 2*np.pi, 100) plt.plot(R_earth * np.cos(theta), R_earth * np.sin(theta), 'k', label='Earth') for label, v0_mag in velocity_cases: v0 = np.array([0, v0_mag]) traj = simulate_trajectory(r0.copy(), v0.copy(), dt=1, t_max=10000) plt.plot(traj[:,0], traj[:,1], label=label) plt.axis('equal') plt.xlabel(\"x [m]\") plt.ylabel(\"y [m]\") plt.title(\"Payload Trajectories Released Near Earth\") plt.legend() plt.grid(True) plt.show() 4. Interpretation of Results Suborbital: The payload falls back to Earth, possibly reentering. Circular Orbit: The payload remains in stable orbit. Elliptical Orbit: The payload enters a higher apogee orbit. Escape Trajectory: The payload leaves Earth\u2019s gravitational field. Escape Velocity: v_esc = sqrt(2GM / r) \u2248 11.2 km/s at surface 5. Applications in Space Missions Orbital Insertion: Payloads must match circular/elliptical criteria. Reentry Capsules: Suborbital trajectories ensure atmospheric return. Interplanetary Missions: Escape trajectories enable transfers to other planets. 6. Conclusion This analysis demonstrates how classical mechanics and numerical methods provide insights into orbital dynamics. Understanding the nature of a trajectory based on velocity and position at release is fundamental in aerospace engineering and astrodynamics.","title":"Problem 3"},{"location":"1%20Physics/3%20Waves/Problem_1/","text":"\ud83c\udf0a Interference Patterns on a Water Surface Motivation Interference patterns provide a vivid, intuitive view of wave behavior. On a water surface, these patterns arise when waves from different sources overlap. The resulting pattern reveals how waves interact constructively or destructively depending on their relative phases and distances. This simple yet powerful model helps us grasp key concepts of wave physics. \ud83d\udd27 Problem Setup Regular Polygon Selection We choose a regular pentagon (5-sided polygon) for placing our wave sources. Parameters Amplitude (A): 1.0 Wavelength (\u03bb): 1.0 unit Frequency (f): 1.0 Hz Wave number (k): \\( k = \\frac{2\\pi}{\\lambda} \\) Angular frequency (\u03c9): \\( \\omega = 2\\pi f \\) Phase (\u03d5): 0 (coherent sources) \ud83e\uddee Wave Equation For a single source at location \\(\\vec{r}_i = (x_i, y_i)\\) , the wave displacement at point \\(\\vec{r} = (x, y)\\) and time \\(t\\) is: \\[ \\psi_i(x, y, t) = A \\cdot \\cos(k d_i - \\omega t + \\phi) \\] where: - \\(d_i = \\sqrt{(x - x_i)^2 + (y - y_i)^2}\\) The total wave displacement from all sources is: \\[ \\Psi(x, y, t) = \\sum_{i=1}^{N} \\psi_i(x, y, t) \\] \ud83e\uddd1\u200d\ud83d\udcbb Python Simulation Code import numpy as np import matplotlib.pyplot as plt # Parameters A = 1.0 wavelength = 1.0 k = 2 * np.pi / wavelength f = 1.0 omega = 2 * np.pi * f phi = 0 N_sources = 5 # regular pentagon # Time snapshot t = 0.0 # Grid x = np.linspace(-5, 5, 500) y = np.linspace(-5, 5, 500) X, Y = np.meshgrid(x, y) # Position sources at vertices of a regular pentagon radius = 2.0 angles = np.linspace(0, 2*np.pi, N_sources, endpoint=False) source_positions = [(radius * np.cos(a), radius * np.sin(a)) for a in angles] # Superpose waves from all sources Z = np.zeros_like(X) for (x0, y0) in source_positions: R = np.sqrt((X - x0)**2 + (Y - y0)**2) Z += A * np.cos(k * R - omega * t + phi) # Visualization plt.figure(figsize=(8, 6)) plt.contourf(X, Y, Z, levels=100, cmap='viridis') plt.colorbar(label='Wave Displacement') plt.scatter(*zip(*source_positions), color='red', label='Sources') plt.title('Interference Pattern from 5 Point Sources (Pentagon)') plt.xlabel('x') plt.ylabel('y') plt.legend() plt.axis('equal') plt.show() \ud83d\udd0d Analysis of Interference Patterns Constructive Interference Occurs where the waves from all sources arrive in phase \u2014 seen as bright (high-displacement) fringes. Destructive Interference Occurs where the waves are out of phase \u2014 seen as dark (low-displacement) regions. Symmetry Observed The pattern has pentagonal symmetry , reflecting the geometry of the source configuration. Regions of symmetry correspond to central lines between source pairs. \ud83d\udcc8 Conclusion This simulation of interference patterns from point sources arranged in a regular pentagon reveals: - Radial and angular symmetries matching the source geometry. - Rich, periodic structures caused by constructive and destructive interference. - A powerful way to explore wave superposition , using a visually intuitive and computationally accessible method.","title":"\ud83c\udf0a Interference Patterns on a Water Surface"},{"location":"1%20Physics/3%20Waves/Problem_1/#interference-patterns-on-a-water-surface","text":"","title":"\ud83c\udf0a Interference Patterns on a Water Surface"},{"location":"1%20Physics/3%20Waves/Problem_1/#motivation","text":"Interference patterns provide a vivid, intuitive view of wave behavior. On a water surface, these patterns arise when waves from different sources overlap. The resulting pattern reveals how waves interact constructively or destructively depending on their relative phases and distances. This simple yet powerful model helps us grasp key concepts of wave physics.","title":"Motivation"},{"location":"1%20Physics/3%20Waves/Problem_1/#problem-setup","text":"","title":"\ud83d\udd27 Problem Setup"},{"location":"1%20Physics/3%20Waves/Problem_1/#regular-polygon-selection","text":"We choose a regular pentagon (5-sided polygon) for placing our wave sources.","title":"Regular Polygon Selection"},{"location":"1%20Physics/3%20Waves/Problem_1/#parameters","text":"Amplitude (A): 1.0 Wavelength (\u03bb): 1.0 unit Frequency (f): 1.0 Hz Wave number (k): \\( k = \\frac{2\\pi}{\\lambda} \\) Angular frequency (\u03c9): \\( \\omega = 2\\pi f \\) Phase (\u03d5): 0 (coherent sources)","title":"Parameters"},{"location":"1%20Physics/3%20Waves/Problem_1/#wave-equation","text":"For a single source at location \\(\\vec{r}_i = (x_i, y_i)\\) , the wave displacement at point \\(\\vec{r} = (x, y)\\) and time \\(t\\) is: \\[ \\psi_i(x, y, t) = A \\cdot \\cos(k d_i - \\omega t + \\phi) \\] where: - \\(d_i = \\sqrt{(x - x_i)^2 + (y - y_i)^2}\\) The total wave displacement from all sources is: \\[ \\Psi(x, y, t) = \\sum_{i=1}^{N} \\psi_i(x, y, t) \\]","title":"\ud83e\uddee Wave Equation"},{"location":"1%20Physics/3%20Waves/Problem_1/#python-simulation-code","text":"import numpy as np import matplotlib.pyplot as plt # Parameters A = 1.0 wavelength = 1.0 k = 2 * np.pi / wavelength f = 1.0 omega = 2 * np.pi * f phi = 0 N_sources = 5 # regular pentagon # Time snapshot t = 0.0 # Grid x = np.linspace(-5, 5, 500) y = np.linspace(-5, 5, 500) X, Y = np.meshgrid(x, y) # Position sources at vertices of a regular pentagon radius = 2.0 angles = np.linspace(0, 2*np.pi, N_sources, endpoint=False) source_positions = [(radius * np.cos(a), radius * np.sin(a)) for a in angles] # Superpose waves from all sources Z = np.zeros_like(X) for (x0, y0) in source_positions: R = np.sqrt((X - x0)**2 + (Y - y0)**2) Z += A * np.cos(k * R - omega * t + phi) # Visualization plt.figure(figsize=(8, 6)) plt.contourf(X, Y, Z, levels=100, cmap='viridis') plt.colorbar(label='Wave Displacement') plt.scatter(*zip(*source_positions), color='red', label='Sources') plt.title('Interference Pattern from 5 Point Sources (Pentagon)') plt.xlabel('x') plt.ylabel('y') plt.legend() plt.axis('equal') plt.show()","title":"\ud83e\uddd1\u200d\ud83d\udcbb Python Simulation Code"},{"location":"1%20Physics/3%20Waves/Problem_1/#analysis-of-interference-patterns","text":"","title":"\ud83d\udd0d Analysis of Interference Patterns"},{"location":"1%20Physics/3%20Waves/Problem_1/#constructive-interference","text":"Occurs where the waves from all sources arrive in phase \u2014 seen as bright (high-displacement) fringes.","title":"Constructive Interference"},{"location":"1%20Physics/3%20Waves/Problem_1/#destructive-interference","text":"Occurs where the waves are out of phase \u2014 seen as dark (low-displacement) regions.","title":"Destructive Interference"},{"location":"1%20Physics/3%20Waves/Problem_1/#symmetry-observed","text":"The pattern has pentagonal symmetry , reflecting the geometry of the source configuration. Regions of symmetry correspond to central lines between source pairs.","title":"Symmetry Observed"},{"location":"1%20Physics/3%20Waves/Problem_1/#conclusion","text":"This simulation of interference patterns from point sources arranged in a regular pentagon reveals: - Radial and angular symmetries matching the source geometry. - Rich, periodic structures caused by constructive and destructive interference. - A powerful way to explore wave superposition , using a visually intuitive and computationally accessible method.","title":"\ud83d\udcc8 Conclusion"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/5%20Circuits/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/5%20Circuits/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_2/","text":"Problem 2","title":"Problem 2"},{"location":"1%20Physics/6%20Statistics/Problem_2/#problem-2","text":"","title":"Problem 2"},{"location":"1%20Physics/7%20Measurements/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/7%20Measurements/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"2%20Mathematics/1%20Linear_algebra/","text":"Linear Algebra","title":"Linear Algebra"},{"location":"2%20Mathematics/1%20Linear_algebra/#linear-algebra","text":"","title":"Linear Algebra"},{"location":"2%20Mathematics/2%20Analytic_geometry/","text":"Analytic geometry","title":"Analytic geometry"},{"location":"2%20Mathematics/2%20Analytic_geometry/#analytic-geometry","text":"","title":"Analytic geometry"},{"location":"2%20Mathematics/3%20Calculus/","text":"Calculus","title":"Calculus"},{"location":"2%20Mathematics/3%20Calculus/#calculus","text":"","title":"Calculus"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_02%20Set_Theory/","text":"Set Theory","title":"Set Theory"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_02%20Set_Theory/#set-theory","text":"","title":"Set Theory"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_03%20Relations/","text":"Relations","title":"Relations"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_03%20Relations/#relations","text":"","title":"Relations"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_04%20Functions/","text":"Functions","title":"Functions"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_04%20Functions/#functions","text":"","title":"Functions"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_05%20Combinatorics/","text":"Combinatorics","title":"Combinatorics"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_05%20Combinatorics/#combinatorics","text":"","title":"Combinatorics"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_08%20Number_Theory/","text":"Number Theory","title":"Number Theory"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_08%20Number_Theory/#number-theory","text":"","title":"Number Theory"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_06%20Sequences_and_Series/","text":"Sequences and Series","title":"Sequences and Series"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_06%20Sequences_and_Series/#sequences-and-series","text":"","title":"Sequences and Series"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_07%20Induction/","text":"Induction","title":"Induction"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_07%20Induction/#induction","text":"","title":"Induction"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_09%20Recurrence/","text":"Recurrence","title":"Recurrence"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_09%20Recurrence/#recurrence","text":"","title":"Recurrence"},{"location":"3%20Discret_Mathematics/4%20Graph%20Theory%20and%20.../_10%20Graph_Theory/","text":"Graph Theory","title":"Graph Theory"},{"location":"3%20Discret_Mathematics/4%20Graph%20Theory%20and%20.../_10%20Graph_Theory/#graph-theory","text":"","title":"Graph Theory"},{"location":"3%20Discret_Mathematics/5%20Logic/_01%20Logic/","text":"Logic","title":"Logic"},{"location":"3%20Discret_Mathematics/5%20Logic/_01%20Logic/#logic","text":"","title":"Logic"}]}