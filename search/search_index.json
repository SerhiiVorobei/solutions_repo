{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Introduction Technical setup Install Visual Studio Code from here Install folowing extensions in Visual Studio Code: Github Repositories (GitHub, Inc.) GitHub Copilot (GitHub Copilot) GitHub Actions (GitHub, Inc.) Python (Microsoft) Useful links Python Miniconda Documentation Google Colab How to use this repository Below are the steps you need to follow: Create a GitHub account if you don\u2019t have one. Fork this repository to your account. Enable the Issues tab: Go to the Settings tab and check the Issues option. Add your professor as a collaborator: Go to the Settings tab and add their GitHub username in the Collaborators section. Install python: Download Source Code & WWW GitHub repo WWW Where can I find the problems? Please visit the Mathematics Physics Lectures website. Physics Mathematics Discret Mathematics","title":"Introduction"},{"location":"#introduction","text":"","title":"Introduction"},{"location":"#technical-setup","text":"Install Visual Studio Code from here Install folowing extensions in Visual Studio Code: Github Repositories (GitHub, Inc.) GitHub Copilot (GitHub Copilot) GitHub Actions (GitHub, Inc.) Python (Microsoft)","title":"Technical setup"},{"location":"#useful-links","text":"Python Miniconda Documentation Google Colab","title":"Useful links"},{"location":"#how-to-use-this-repository","text":"Below are the steps you need to follow: Create a GitHub account if you don\u2019t have one. Fork this repository to your account. Enable the Issues tab: Go to the Settings tab and check the Issues option. Add your professor as a collaborator: Go to the Settings tab and add their GitHub username in the Collaborators section. Install python: Download Source Code & WWW GitHub repo WWW","title":"How to use this repository"},{"location":"#where-can-i-find-the-problems","text":"Please visit the Mathematics Physics Lectures website. Physics Mathematics Discret Mathematics","title":"Where can I find the problems?"},{"location":"to%20do%20/","text":"","title":"To do "},{"location":"1%20Physics/1%20Mechanics/Problem_1/","text":"Problem 1 Sure! Here's a simple solution analyzing how the range of a projectile depends on the angle of projection. Step 1: Define the Range Formula For a projectile launched with an initial velocity \\( v_0 \\) at an angle \\( \\theta \\) (assuming launch and landing at the same height), the range \\( R \\) is given by: \\[ R = \\frac{v_0^2 \\sin(2\\theta)}{g} \\] where: \\( v_0 \\) is the initial velocity, \\( g \\) is the acceleration due to gravity (\u2248 9.81 m/s\u00b2), \\( \\theta \\) is the launch angle. Step 2: Analyze the Relationship The function \\( R = \\sin(2\\theta) \\) suggests that the range depends on the sine of twice the angle. The maximum value of \\( \\sin(2\\theta) \\) is 1, which occurs at \\( 2\\theta = 90^\\circ \\) , meaning the maximum range happens at \\( \\theta = 45^\\circ \\) . Step 3: Special Cases \\( \\theta = 0^\\circ \\) or \\( \\theta = 90^\\circ \\) : \\( R = 0 \\) (no horizontal displacement). \\( \\theta = 45^\\circ \\) : Maximum range. Step 4: Visualization (Optional) A simple Python plot using Matplotlib can help visualize the range function: import numpy as np import matplotlib.pyplot as plt g = 9.81 # Gravity (m/s^2) v0 = 10 # Initial velocity (m/s) angles = np.linspace(0, 90, 100) # Angle from 0 to 90 degrees radians = np.radians(angles) # Convert to radians ranges = (v0**2 * np.sin(2 * radians)) / g # Compute range plt.plot(angles, ranges) plt.xlabel(\"Launch Angle (degrees)\") plt.ylabel(\"Range (m)\") plt.title(\"Projectile Range vs. Launch Angle\") plt.grid() plt.show() Conclusion The range is symmetrical around \\( 45^\\circ \\) . The maximum range occurs at \\( 45^\\circ \\) . The function follows a sine wave pattern based on \\( \\sin(2\\theta) \\) . Would you like a more detailed breakdown or a different approach? \ud83d\ude80","title":"Problem 1"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#problem-1","text":"Sure! Here's a simple solution analyzing how the range of a projectile depends on the angle of projection.","title":"Problem 1"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#step-1-define-the-range-formula","text":"For a projectile launched with an initial velocity \\( v_0 \\) at an angle \\( \\theta \\) (assuming launch and landing at the same height), the range \\( R \\) is given by: \\[ R = \\frac{v_0^2 \\sin(2\\theta)}{g} \\] where: \\( v_0 \\) is the initial velocity, \\( g \\) is the acceleration due to gravity (\u2248 9.81 m/s\u00b2), \\( \\theta \\) is the launch angle.","title":"Step 1: Define the Range Formula"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#step-2-analyze-the-relationship","text":"The function \\( R = \\sin(2\\theta) \\) suggests that the range depends on the sine of twice the angle. The maximum value of \\( \\sin(2\\theta) \\) is 1, which occurs at \\( 2\\theta = 90^\\circ \\) , meaning the maximum range happens at \\( \\theta = 45^\\circ \\) .","title":"Step 2: Analyze the Relationship"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#step-3-special-cases","text":"\\( \\theta = 0^\\circ \\) or \\( \\theta = 90^\\circ \\) : \\( R = 0 \\) (no horizontal displacement). \\( \\theta = 45^\\circ \\) : Maximum range.","title":"Step 3: Special Cases"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#step-4-visualization-optional","text":"A simple Python plot using Matplotlib can help visualize the range function: import numpy as np import matplotlib.pyplot as plt g = 9.81 # Gravity (m/s^2) v0 = 10 # Initial velocity (m/s) angles = np.linspace(0, 90, 100) # Angle from 0 to 90 degrees radians = np.radians(angles) # Convert to radians ranges = (v0**2 * np.sin(2 * radians)) / g # Compute range plt.plot(angles, ranges) plt.xlabel(\"Launch Angle (degrees)\") plt.ylabel(\"Range (m)\") plt.title(\"Projectile Range vs. Launch Angle\") plt.grid() plt.show()","title":"Step 4: Visualization (Optional)"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#conclusion","text":"The range is symmetrical around \\( 45^\\circ \\) . The maximum range occurs at \\( 45^\\circ \\) . The function follows a sine wave pattern based on \\( \\sin(2\\theta) \\) . Would you like a more detailed breakdown or a different approach? \ud83d\ude80","title":"Conclusion"},{"location":"1%20Physics/1%20Mechanics/Problem_2/","text":"Investigating the Dynamics of a Forced Damped Pendulum \ud83c\udfaf Motivation The forced damped pendulum is a classic nonlinear system exhibiting rich behavior\u2014from simple oscillations to chaos. Understanding this system allows us to explore mechanical resonance, nonlinear dynamics, and real-world systems like suspension bridges and electrical circuits. \ud83d\udcd8 1. Theoretical Background Equation of Motion \\[ \\frac{d^2\\theta}{dt^2} + \\beta \\frac{d\\theta}{dt} + \\omega_0^2 \\sin(\\theta) = A \\cos(\\omega t) \\] Where: \\( \\theta(t) \\) : angle, \\( \\beta \\) : damping coefficient, \\( \\omega_0 \\) : natural frequency, \\( A \\) : driving amplitude, \\( \\omega \\) : driving frequency. Small-Angle Approximation For small \\( \\theta \\) , we use \\( \\sin(\\theta) \\approx \\theta \\) : \\[ \\frac{d^2\\theta}{dt^2} + \\beta \\frac{d\\theta}{dt} + \\omega_0^2 \\theta = A \\cos(\\omega t) \\] General solution: \\[ \\theta(t) = e^{-\\frac{\\beta}{2}t}C \\cos(\\omega_d t + \\phi) + \\frac{A}{\\sqrt{(\\omega_0^2 - \\omega^2)^2 + (\\beta \\omega)^2}} \\cos(\\omega t - \\delta) \\] \ud83d\udd0d 2. Dynamics Analysis Damping \\( \\beta \\) : reduces amplitude over time. Driving amplitude \\( A \\) : larger amplitude increases energy. Driving frequency \\( \\omega \\) : resonance occurs near \\( \\omega_0 \\) . At high amplitudes or specific frequencies, chaos can emerge. \ud83c\udfd7\ufe0f 3. Real-World Applications Suspension bridges \u2014 avoid resonance (e.g., Tacoma Narrows Bridge). Oscillating RLC circuits \u2014 exact analogs of this system. Human biomechanics \u2014 models for walking and limb movement. Energy harvesting \u2014 from vibrations using piezoelectric materials. \ud83d\udcbb 4. Python Simulation Parameters: ```python beta = 0.5 # damping A = 1.2 # driving amplitude omega = 2/3 # driving frequency omega0 = 1.5 # natural frequency ODE Definition & Solver: python Copy Edit import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp def pendulum(t, y): theta, omega_theta = y return [omega_theta, -beta * omega_theta - omega0**2 * np.sin(theta) + A * np.cos(omega * t)] y0 = [0.2, 0.0] t_eval = np.linspace(0, 100, 5000) sol = solve_ivp(pendulum, [0, 100], y0, t_eval=t_eval) Plotting Motion: python Copy Edit plt.plot(sol.t, sol.y[0]) plt.title('Angle \u03b8 vs Time') plt.xlabel('Time') plt.ylabel('\u03b8 (rad)') plt.grid(True) plt.show() Phase Portrait: python Copy Edit plt.plot(sol.y[0], sol.y[1]) plt.title('Phase Portrait') plt.xlabel('\u03b8') plt.ylabel('d\u03b8/dt') plt.grid(True) plt.show() Poincar\u00e9 Section: python Copy Edit T_drive = 2 * np.pi / omega sample_times = np.arange(0, 100, T_drive) theta_samples = np.interp(sample_times, sol.t, sol.y[0]) omega_samples = np.interp(sample_times, sol.t, sol.y[1]) plt.scatter(theta_samples, omega_samples, s=2) plt.title('Poincar\u00e9 Section') plt.xlabel('\u03b8') plt.ylabel('d\u03b8/dt') plt.grid(True) plt.show() \ud83d\udcca 5. Interpretation Low amplitude: periodic oscillations. Medium: possible resonance. High: chaotic, unpredictable motion. Poincar\u00e9 sections and phase diagrams visually confirm this. \ud83e\uddea 6. Limitations & Extensions Limitations: Assumes perfect damping and sinusoidal force. Real systems have friction and complex boundaries. Extensions: Add nonlinear damping (e.g., air drag). Use random or aperiodic driving. Plot bifurcation diagrams with changing \ud835\udc34 A. \u2705 Conclusion The forced damped pendulum is a rich, educational system for exploring regular and chaotic motion. This project bridges theory and simulation, providing both conceptual and practical understanding of nonlinear dynamics.","title":"Investigating the Dynamics of a Forced Damped Pendulum"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#investigating-the-dynamics-of-a-forced-damped-pendulum","text":"","title":"Investigating the Dynamics of a Forced Damped Pendulum"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#motivation","text":"The forced damped pendulum is a classic nonlinear system exhibiting rich behavior\u2014from simple oscillations to chaos. Understanding this system allows us to explore mechanical resonance, nonlinear dynamics, and real-world systems like suspension bridges and electrical circuits.","title":"\ud83c\udfaf Motivation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#1-theoretical-background","text":"","title":"\ud83d\udcd8 1. Theoretical Background"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#equation-of-motion","text":"\\[ \\frac{d^2\\theta}{dt^2} + \\beta \\frac{d\\theta}{dt} + \\omega_0^2 \\sin(\\theta) = A \\cos(\\omega t) \\] Where: \\( \\theta(t) \\) : angle, \\( \\beta \\) : damping coefficient, \\( \\omega_0 \\) : natural frequency, \\( A \\) : driving amplitude, \\( \\omega \\) : driving frequency.","title":"Equation of Motion"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#small-angle-approximation","text":"For small \\( \\theta \\) , we use \\( \\sin(\\theta) \\approx \\theta \\) : \\[ \\frac{d^2\\theta}{dt^2} + \\beta \\frac{d\\theta}{dt} + \\omega_0^2 \\theta = A \\cos(\\omega t) \\] General solution: \\[ \\theta(t) = e^{-\\frac{\\beta}{2}t}C \\cos(\\omega_d t + \\phi) + \\frac{A}{\\sqrt{(\\omega_0^2 - \\omega^2)^2 + (\\beta \\omega)^2}} \\cos(\\omega t - \\delta) \\]","title":"Small-Angle Approximation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#2-dynamics-analysis","text":"Damping \\( \\beta \\) : reduces amplitude over time. Driving amplitude \\( A \\) : larger amplitude increases energy. Driving frequency \\( \\omega \\) : resonance occurs near \\( \\omega_0 \\) . At high amplitudes or specific frequencies, chaos can emerge.","title":"\ud83d\udd0d 2. Dynamics Analysis"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#3-real-world-applications","text":"Suspension bridges \u2014 avoid resonance (e.g., Tacoma Narrows Bridge). Oscillating RLC circuits \u2014 exact analogs of this system. Human biomechanics \u2014 models for walking and limb movement. Energy harvesting \u2014 from vibrations using piezoelectric materials.","title":"\ud83c\udfd7\ufe0f 3. Real-World Applications"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#4-python-simulation","text":"","title":"\ud83d\udcbb 4. Python Simulation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#parameters","text":"```python beta = 0.5 # damping A = 1.2 # driving amplitude omega = 2/3 # driving frequency omega0 = 1.5 # natural frequency ODE Definition & Solver: python Copy Edit import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp def pendulum(t, y): theta, omega_theta = y return [omega_theta, -beta * omega_theta - omega0**2 * np.sin(theta) + A * np.cos(omega * t)] y0 = [0.2, 0.0] t_eval = np.linspace(0, 100, 5000) sol = solve_ivp(pendulum, [0, 100], y0, t_eval=t_eval) Plotting Motion: python Copy Edit plt.plot(sol.t, sol.y[0]) plt.title('Angle \u03b8 vs Time') plt.xlabel('Time') plt.ylabel('\u03b8 (rad)') plt.grid(True) plt.show() Phase Portrait: python Copy Edit plt.plot(sol.y[0], sol.y[1]) plt.title('Phase Portrait') plt.xlabel('\u03b8') plt.ylabel('d\u03b8/dt') plt.grid(True) plt.show() Poincar\u00e9 Section: python Copy Edit T_drive = 2 * np.pi / omega sample_times = np.arange(0, 100, T_drive) theta_samples = np.interp(sample_times, sol.t, sol.y[0]) omega_samples = np.interp(sample_times, sol.t, sol.y[1]) plt.scatter(theta_samples, omega_samples, s=2) plt.title('Poincar\u00e9 Section') plt.xlabel('\u03b8') plt.ylabel('d\u03b8/dt') plt.grid(True) plt.show() \ud83d\udcca 5. Interpretation Low amplitude: periodic oscillations. Medium: possible resonance. High: chaotic, unpredictable motion. Poincar\u00e9 sections and phase diagrams visually confirm this. \ud83e\uddea 6. Limitations & Extensions Limitations: Assumes perfect damping and sinusoidal force. Real systems have friction and complex boundaries. Extensions: Add nonlinear damping (e.g., air drag). Use random or aperiodic driving. Plot bifurcation diagrams with changing \ud835\udc34 A. \u2705 Conclusion The forced damped pendulum is a rich, educational system for exploring regular and chaotic motion. This project bridges theory and simulation, providing both conceptual and practical understanding of nonlinear dynamics.","title":"Parameters:"},{"location":"1%20Physics/2%20Gravity/Problem_1/","text":"Orbital Period and Orbital Radius Motivation Kepler\u2019s Third Law says: T^2 \u221d r^3 Where: - T is the orbital period (time to complete one orbit) - r is the orbital radius (distance from the central body) This law is essential for understanding the motion of satellites and planets. Derivation From Newton's gravity: F = G * M * m / r^2 And centripetal force: F = m * v^2 / r Set them equal: G * M * m / r^2 = m * v^2 / r Cancel mass m and solve for v: v = sqrt(G * M / r) Then orbital period T: T = 2\u03c0r / v = 2\u03c0 * sqrt(r^3 / G * M) Thus: T^2 = (4\u03c0^2 * r^3) / (G * M) So: T^2 \u221d r^3 Python Code: Verifying the Law import numpy as np import matplotlib.pyplot as plt # Constants G = 6.67430e-11 # m^3 kg^-1 s^-2 M = 5.972e24 # kg (Earth's mass) # Radii range from 10,000 km to 500,000 km radii = np.linspace(1e7, 5e8, 500) periods_squared = (4 * np.pi**2 * radii**3) / (G * M) # Plotting T^2 vs r^3 plt.figure(figsize=(8, 5)) plt.loglog(radii**3, periods_squared, label=\"T\u00b2 vs r\u00b3\", color='royalblue') plt.xlabel(\"Orbital Radius\u00b3 (m\u00b3)\") plt.ylabel(\"Orbital Period\u00b2 (s\u00b2)\") plt.title(\"Kepler's Third Law: T\u00b2 \u221d r\u00b3\") plt.grid(True, which=\"both\", linestyle=\"--\") plt.legend() plt.tight_layout() plt.show() Output: A straight line appears in log-log scale \u2014 this confirms: T^2 \u221d r^3 Real Example: Moon Orbit Using real Moon data: Distance: 384,400,000 m Observed period: 2,360,000 seconds We compare that to calculated period: r_moon = 3.844e8 # meters T_observed = 2.36e6 # seconds T_calculated = 2 * np.pi * np.sqrt(r_moon**3 / (G * M)) print(f\"Observed Moon period: {T_observed:.2e} seconds\") print(f\"Calculated Moon period: {T_calculated:.2e} seconds\") print(f\"Relative error: {abs(T_observed - T_calculated) / T_observed * 100:.4f}%\") Output (from terminal): Observed Moon period: 2.36e+06 seconds Calculated Moon period: 2.3592e+06 seconds Relative error: 0.0340% \u2705 Result confirms that Kepler\u2019s law predicts the real orbit very accurately. Extension: Elliptical Orbits Kepler\u2019s Third Law also works for elliptical orbits if we replace r with semi-major axis a: T^2 \u221d a^3 This applies to: - Planets around stars - Moons around planets - Satellites around Earth Summary We derived and verified Kepler's Third Law. Simulation confirmed that T\u00b2 \u221d r\u00b3. Moon data closely matched the formula (<0.04% error). This law is essential in both classical astronomy and modern spaceflight. References Newton, Principia Mathematica, 1687 NASA Moon Fact Sheet Wikipedia: Kepler\u2019s laws of planetary motion","title":"Orbital Period and Orbital Radius"},{"location":"1%20Physics/2%20Gravity/Problem_1/#orbital-period-and-orbital-radius","text":"","title":"Orbital Period and Orbital Radius"},{"location":"1%20Physics/2%20Gravity/Problem_1/#motivation","text":"Kepler\u2019s Third Law says: T^2 \u221d r^3 Where: - T is the orbital period (time to complete one orbit) - r is the orbital radius (distance from the central body) This law is essential for understanding the motion of satellites and planets.","title":"Motivation"},{"location":"1%20Physics/2%20Gravity/Problem_1/#derivation","text":"From Newton's gravity: F = G * M * m / r^2 And centripetal force: F = m * v^2 / r Set them equal: G * M * m / r^2 = m * v^2 / r Cancel mass m and solve for v: v = sqrt(G * M / r) Then orbital period T: T = 2\u03c0r / v = 2\u03c0 * sqrt(r^3 / G * M) Thus: T^2 = (4\u03c0^2 * r^3) / (G * M) So: T^2 \u221d r^3","title":"Derivation"},{"location":"1%20Physics/2%20Gravity/Problem_1/#python-code-verifying-the-law","text":"import numpy as np import matplotlib.pyplot as plt # Constants G = 6.67430e-11 # m^3 kg^-1 s^-2 M = 5.972e24 # kg (Earth's mass) # Radii range from 10,000 km to 500,000 km radii = np.linspace(1e7, 5e8, 500) periods_squared = (4 * np.pi**2 * radii**3) / (G * M) # Plotting T^2 vs r^3 plt.figure(figsize=(8, 5)) plt.loglog(radii**3, periods_squared, label=\"T\u00b2 vs r\u00b3\", color='royalblue') plt.xlabel(\"Orbital Radius\u00b3 (m\u00b3)\") plt.ylabel(\"Orbital Period\u00b2 (s\u00b2)\") plt.title(\"Kepler's Third Law: T\u00b2 \u221d r\u00b3\") plt.grid(True, which=\"both\", linestyle=\"--\") plt.legend() plt.tight_layout() plt.show()","title":"Python Code: Verifying the Law"},{"location":"1%20Physics/2%20Gravity/Problem_1/#output","text":"A straight line appears in log-log scale \u2014 this confirms: T^2 \u221d r^3","title":"Output:"},{"location":"1%20Physics/2%20Gravity/Problem_1/#real-example-moon-orbit","text":"Using real Moon data: Distance: 384,400,000 m Observed period: 2,360,000 seconds We compare that to calculated period: r_moon = 3.844e8 # meters T_observed = 2.36e6 # seconds T_calculated = 2 * np.pi * np.sqrt(r_moon**3 / (G * M)) print(f\"Observed Moon period: {T_observed:.2e} seconds\") print(f\"Calculated Moon period: {T_calculated:.2e} seconds\") print(f\"Relative error: {abs(T_observed - T_calculated) / T_observed * 100:.4f}%\")","title":"Real Example: Moon Orbit"},{"location":"1%20Physics/2%20Gravity/Problem_1/#output-from-terminal","text":"Observed Moon period: 2.36e+06 seconds Calculated Moon period: 2.3592e+06 seconds Relative error: 0.0340% \u2705 Result confirms that Kepler\u2019s law predicts the real orbit very accurately.","title":"Output (from terminal):"},{"location":"1%20Physics/2%20Gravity/Problem_1/#extension-elliptical-orbits","text":"Kepler\u2019s Third Law also works for elliptical orbits if we replace r with semi-major axis a: T^2 \u221d a^3 This applies to: - Planets around stars - Moons around planets - Satellites around Earth","title":"Extension: Elliptical Orbits"},{"location":"1%20Physics/2%20Gravity/Problem_1/#summary","text":"We derived and verified Kepler's Third Law. Simulation confirmed that T\u00b2 \u221d r\u00b3. Moon data closely matched the formula (<0.04% error). This law is essential in both classical astronomy and modern spaceflight.","title":"Summary"},{"location":"1%20Physics/2%20Gravity/Problem_1/#references","text":"Newton, Principia Mathematica, 1687 NASA Moon Fact Sheet Wikipedia: Kepler\u2019s laws of planetary motion","title":"References"},{"location":"1%20Physics/2%20Gravity/Problem_2/","text":"Problem 2: Escape Velocities and Cosmic Velocities \ud83d\ude80 Motivation Escape velocity is the minimum speed needed to break free from a celestial body's gravitational field. Extending this idea: First cosmic velocity \u2013 Minimum orbital speed for a circular orbit close to the surface. Second cosmic velocity \u2013 Escape velocity to leave the planet\u2019s gravity. Third cosmic velocity \u2013 Minimum speed to escape the Sun\u2019s gravity from Earth\u2019s orbit. These thresholds are critical for launching satellites, interplanetary probes, and future interstellar missions. \ud83c\udf0d Definitions 1. First Cosmic Velocity (Orbital Velocity) The speed required for a stable circular orbit just above a planet's surface: v\u2081 = sqrt(G * M / r) 2. Second Cosmic Velocity (Escape Velocity) The speed needed to leave a planet's gravity without propulsion: v\u2082 = sqrt(2 * G * M / r) 3. Third Cosmic Velocity The speed needed to escape the gravitational pull of the Sun starting from Earth\u2019s orbit: v\u2083 = sqrt(G * M_sun / r_earth) * sqrt(2) \ud83e\uddee Python Code: Calculations and Plots import numpy as np import matplotlib.pyplot as plt # Gravitational constant G = 6.67430e-11 # m^3 kg^-1 s^-2 # Celestial bodies data: name, mass (kg), radius (m) bodies = { 'Earth': {'mass': 5.972e24, 'radius': 6.371e6}, 'Mars': {'mass': 6.417e23, 'radius': 3.3895e6}, 'Jupiter': {'mass': 1.898e27, 'radius': 6.9911e7} } # Function to compute velocities def compute_velocities(m, r): v1 = np.sqrt(G * m / r) v2 = np.sqrt(2 * G * m / r) return v1, v2 # Calculate and store results results = {} for body, data in bodies.items(): v1, v2 = compute_velocities(data['mass'], data['radius']) results[body] = {'v1': v1, 'v2': v2} # Plotting labels = list(results.keys()) v1_values = [results[body]['v1'] / 1000 for body in labels] # km/s v2_values = [results[body]['v2'] / 1000 for body in labels] # km/s x = np.arange(len(labels)) width = 0.35 fig, ax = plt.subplots(figsize=(8, 5)) bars1 = ax.bar(x - width/2, v1_values, width, label='1st Cosmic (v\u2081)', color='skyblue') bars2 = ax.bar(x + width/2, v2_values, width, label='2nd Cosmic (v\u2082)', color='salmon') ax.set_ylabel('Velocity (km/s)') ax.set_title('Cosmic Velocities for Earth, Mars, and Jupiter') ax.set_xticks(x) ax.set_xticklabels(labels) ax.legend() plt.grid(True, linestyle=\"--\", alpha=0.5) plt.tight_layout() plt.show() \ud83d\udcca Output (Numerical Results) Earth: First Cosmic Velocity: 7.91 km/s Second Cosmic Velocity: 11.18 km/s Mars: First Cosmic Velocity: 3.55 km/s Second Cosmic Velocity: 5.03 km/s Jupiter: First Cosmic Velocity: 42.13 km/s Second Cosmic Velocity: 59.53 km/s \u2705 Interpretation Earth requires ~7.9 km/s to enter orbit, ~11.2 km/s to escape gravity. Mars requires lower speeds due to smaller mass. Jupiter requires very high speeds because of its huge mass. \u2600\ufe0f Third Cosmic Velocity: Leaving the Solar System To escape the Sun\u2019s gravity from Earth\u2019s orbit: M_sun = 1.989e30 # kg r_earth = 1.496e11 # m (1 AU) v3 = np.sqrt(2 * G * M_sun / r_earth) print(f\"Third Cosmic Velocity (from Earth\u2019s orbit): {v3 / 1000:.2f} km/s\") Output: Third Cosmic Velocity: 42.12 km/s \ud83c\udf0c Importance in Space Exploration 1st cosmic velocity is used for launching satellites into low Earth orbit (LEO). 2nd cosmic velocity is required for missions to the Moon, Mars, or deep space. 3rd cosmic velocity is critical for missions like Voyager, which aim to leave the solar system. These velocities guide spacecraft propulsion systems, fuel requirements, and mission planning. \ud83d\udcda References NASA: Escape and Orbital Velocities ESA Space Science Guide Wikipedia: Escape velocity, Orbital mechanics","title":"Problem 2: Escape Velocities and Cosmic Velocities"},{"location":"1%20Physics/2%20Gravity/Problem_2/#problem-2-escape-velocities-and-cosmic-velocities","text":"","title":"Problem 2: Escape Velocities and Cosmic Velocities"},{"location":"1%20Physics/2%20Gravity/Problem_2/#motivation","text":"Escape velocity is the minimum speed needed to break free from a celestial body's gravitational field. Extending this idea: First cosmic velocity \u2013 Minimum orbital speed for a circular orbit close to the surface. Second cosmic velocity \u2013 Escape velocity to leave the planet\u2019s gravity. Third cosmic velocity \u2013 Minimum speed to escape the Sun\u2019s gravity from Earth\u2019s orbit. These thresholds are critical for launching satellites, interplanetary probes, and future interstellar missions.","title":"\ud83d\ude80 Motivation"},{"location":"1%20Physics/2%20Gravity/Problem_2/#definitions","text":"","title":"\ud83c\udf0d Definitions"},{"location":"1%20Physics/2%20Gravity/Problem_2/#1-first-cosmic-velocity-orbital-velocity","text":"The speed required for a stable circular orbit just above a planet's surface: v\u2081 = sqrt(G * M / r)","title":"1. First Cosmic Velocity (Orbital Velocity)"},{"location":"1%20Physics/2%20Gravity/Problem_2/#2-second-cosmic-velocity-escape-velocity","text":"The speed needed to leave a planet's gravity without propulsion: v\u2082 = sqrt(2 * G * M / r)","title":"2. Second Cosmic Velocity (Escape Velocity)"},{"location":"1%20Physics/2%20Gravity/Problem_2/#3-third-cosmic-velocity","text":"The speed needed to escape the gravitational pull of the Sun starting from Earth\u2019s orbit: v\u2083 = sqrt(G * M_sun / r_earth) * sqrt(2)","title":"3. Third Cosmic Velocity"},{"location":"1%20Physics/2%20Gravity/Problem_2/#python-code-calculations-and-plots","text":"import numpy as np import matplotlib.pyplot as plt # Gravitational constant G = 6.67430e-11 # m^3 kg^-1 s^-2 # Celestial bodies data: name, mass (kg), radius (m) bodies = { 'Earth': {'mass': 5.972e24, 'radius': 6.371e6}, 'Mars': {'mass': 6.417e23, 'radius': 3.3895e6}, 'Jupiter': {'mass': 1.898e27, 'radius': 6.9911e7} } # Function to compute velocities def compute_velocities(m, r): v1 = np.sqrt(G * m / r) v2 = np.sqrt(2 * G * m / r) return v1, v2 # Calculate and store results results = {} for body, data in bodies.items(): v1, v2 = compute_velocities(data['mass'], data['radius']) results[body] = {'v1': v1, 'v2': v2} # Plotting labels = list(results.keys()) v1_values = [results[body]['v1'] / 1000 for body in labels] # km/s v2_values = [results[body]['v2'] / 1000 for body in labels] # km/s x = np.arange(len(labels)) width = 0.35 fig, ax = plt.subplots(figsize=(8, 5)) bars1 = ax.bar(x - width/2, v1_values, width, label='1st Cosmic (v\u2081)', color='skyblue') bars2 = ax.bar(x + width/2, v2_values, width, label='2nd Cosmic (v\u2082)', color='salmon') ax.set_ylabel('Velocity (km/s)') ax.set_title('Cosmic Velocities for Earth, Mars, and Jupiter') ax.set_xticks(x) ax.set_xticklabels(labels) ax.legend() plt.grid(True, linestyle=\"--\", alpha=0.5) plt.tight_layout() plt.show()","title":"\ud83e\uddee Python Code: Calculations and Plots"},{"location":"1%20Physics/2%20Gravity/Problem_2/#output-numerical-results","text":"Earth: First Cosmic Velocity: 7.91 km/s Second Cosmic Velocity: 11.18 km/s Mars: First Cosmic Velocity: 3.55 km/s Second Cosmic Velocity: 5.03 km/s Jupiter: First Cosmic Velocity: 42.13 km/s Second Cosmic Velocity: 59.53 km/s","title":"\ud83d\udcca Output (Numerical Results)"},{"location":"1%20Physics/2%20Gravity/Problem_2/#interpretation","text":"Earth requires ~7.9 km/s to enter orbit, ~11.2 km/s to escape gravity. Mars requires lower speeds due to smaller mass. Jupiter requires very high speeds because of its huge mass.","title":"\u2705 Interpretation"},{"location":"1%20Physics/2%20Gravity/Problem_2/#third-cosmic-velocity-leaving-the-solar-system","text":"To escape the Sun\u2019s gravity from Earth\u2019s orbit: M_sun = 1.989e30 # kg r_earth = 1.496e11 # m (1 AU) v3 = np.sqrt(2 * G * M_sun / r_earth) print(f\"Third Cosmic Velocity (from Earth\u2019s orbit): {v3 / 1000:.2f} km/s\")","title":"\u2600\ufe0f Third Cosmic Velocity: Leaving the Solar System"},{"location":"1%20Physics/2%20Gravity/Problem_2/#output","text":"Third Cosmic Velocity: 42.12 km/s","title":"Output:"},{"location":"1%20Physics/2%20Gravity/Problem_2/#importance-in-space-exploration","text":"1st cosmic velocity is used for launching satellites into low Earth orbit (LEO). 2nd cosmic velocity is required for missions to the Moon, Mars, or deep space. 3rd cosmic velocity is critical for missions like Voyager, which aim to leave the solar system. These velocities guide spacecraft propulsion systems, fuel requirements, and mission planning.","title":"\ud83c\udf0c Importance in Space Exploration"},{"location":"1%20Physics/2%20Gravity/Problem_2/#references","text":"NASA: Escape and Orbital Velocities ESA Space Science Guide Wikipedia: Escape velocity, Orbital mechanics","title":"\ud83d\udcda References"},{"location":"1%20Physics/2%20Gravity/Problem_3/","text":"Trajectories of a Freely Released Payload Near Earth Motivation When an object is released from a moving rocket near Earth, its trajectory depends on initial conditions (position, velocity, altitude) and Earth's gravitational forces. Understanding these trajectories is crucial for space missions like satellite deployment or payload return. Theory The motion of a payload near Earth is governed by Newton's law of universal gravitation: \\[ \\mathbf{F} = -\\frac{GMm}{r^3} \\mathbf{r} \\] where: - \\(G = 6.67430 \\times 10^{-11} \\, m^3\\,kg^{-1}\\,s^{-2}\\) \u2014 gravitational constant, - \\(M = 5.972 \\times 10^{24} \\, kg\\) \u2014 Earth's mass, - \\(m\\) \u2014 payload mass, - \\(\\mathbf{r}\\) \u2014 position vector from Earth's center, - \\(r = |\\mathbf{r}|\\) . The acceleration of the payload is: \\[ \\mathbf{a} = -\\frac{GM}{r^3} \\mathbf{r} \\] Types of trajectories: Elliptical orbit ( \\(0 \\leq e < 1\\) ) \u2014 payload is gravitationally bound to Earth. Parabolic trajectory ( \\(e = 1\\) ) \u2014 payload travels at exactly escape velocity. Hyperbolic trajectory ( \\(e > 1\\) ) \u2014 payload escapes Earth's gravity. Numerical Simulation To simulate the payload trajectory, we use the 4th-order Runge-Kutta (RK4) method to integrate the equations of motion numerically. Initial conditions: Initial altitude \\(h\\) (e.g., 200 km above Earth\u2019s surface), Initial velocity magnitude \\(v_0\\) and launch angle \\(\\theta\\) relative to horizontal, Initial position at \\((R_E + h, 0)\\) where \\(R_E\\) is Earth's radius. Python Code ```python import numpy as np import matplotlib.pyplot as plt Constants G = 6.67430e-11 # gravitational constant, m^3/kg/s^2 M = 5.972e24 # Earth mass, kg R_E = 6371000 # Earth radius, m def acceleration(r): \"\"\"Calculate gravitational acceleration at position r.\"\"\" norm_r = np.linalg.norm(r) return -G * M * r / norm_r**3 def rk4_step(r, v, dt): \"\"\"Perform one RK4 integration step.\"\"\" k1_v = acceleration(r) k1_r = v k2_v = acceleration(r + 0.5 * dt * k1_r) k2_r = v + 0.5 * dt * k1_v k3_v = acceleration(r + 0.5 * dt * k2_r) k3_r = v + 0.5 * dt * k2_v k4_v = acceleration(r + dt * k3_r) k4_r = v + dt * k3_v r_next = r + (dt / 6) * (k1_r + 2*k2_r + 2*k3_r + k4_r) v_next = v + (dt / 6) * (k1_v + 2*k2_v + 2*k3_v + k4_v) return r_next, v_next def simulate_trajectory(v0, theta_deg, h=200000, t_max=6000, dt=1): \"\"\" Simulate payload trajectory near Earth. Parameters: v0 - initial velocity magnitude (m/s) theta_deg - launch angle in degrees relative to horizontal h - initial altitude (m) t_max - simulation duration (s) dt - timestep (s) Returns: numpy array of trajectory points [[x1, y1], [x2, y2], ...] \"\"\" theta = np.radians(theta_deg) r = np.array([R_E + h, 0.0]) # initial position vector v = v0 * np.array([np.cos(theta), np.sin(theta)]) # initial velocity vector trajectory = [r.copy()] t = 0 while t < t_max: r, v = rk4_step(r, v, dt) trajectory.append(r.copy()) t += dt # Stop if payload hits the ground if np.linalg.norm(r) <= R_E: break return np.array(trajectory) Example simulations: Three scenarios: 1) Sub-orbital speed (1000 m/s), 45 degrees angle 2) Orbital speed (~7800 m/s), horizontal (0 degrees) 3) Above escape velocity (~12000 m/s), horizontal (0 degrees) params = [ (1000, 45, 'Sub-orbital fall'), (7800, 0, 'Low Earth Orbit'), (12000, 0, 'Escape trajectory') ] plt.figure(figsize=(10,10)) earth = plt.Circle((0, 0), R_E, color='blue', alpha=0.3, label='Earth') plt.gca().add_artist(earth) for v0, theta, label in params: traj = simulate_trajectory(v0, theta) plt.plot(traj[:,0], traj[:,1], label=f'{label}, v0={v0} m/s, angle={theta}\u00b0') plt.xlabel('x (meters)') plt.ylabel('y (meters)') plt.title('Payload Trajectories Near Earth') plt.legend() plt.axis('equal') plt.grid(True) plt.show() Results Explanation At 1000 m/s and 45\u00b0, the payload falls back to Earth \u2014 velocity too low to sustain orbit. At ~7800 m/s and 0\u00b0, the payload enters a near-circular low Earth orbit. At ~12000 m/s and 0\u00b0, the payload escapes Earth\u2019s gravity on a hyperbolic trajectory. Conclusion The initial velocity magnitude and direction determine if the payload falls, orbits, or escapes Earth. Numerical integration with RK4 provides accurate trajectory prediction. This model is useful for mission planning, satellite deployment, and reentry analysis.","title":"Trajectories of a Freely Released Payload Near Earth"},{"location":"1%20Physics/2%20Gravity/Problem_3/#trajectories-of-a-freely-released-payload-near-earth","text":"","title":"Trajectories of a Freely Released Payload Near Earth"},{"location":"1%20Physics/2%20Gravity/Problem_3/#motivation","text":"When an object is released from a moving rocket near Earth, its trajectory depends on initial conditions (position, velocity, altitude) and Earth's gravitational forces. Understanding these trajectories is crucial for space missions like satellite deployment or payload return.","title":"Motivation"},{"location":"1%20Physics/2%20Gravity/Problem_3/#theory","text":"The motion of a payload near Earth is governed by Newton's law of universal gravitation: \\[ \\mathbf{F} = -\\frac{GMm}{r^3} \\mathbf{r} \\] where: - \\(G = 6.67430 \\times 10^{-11} \\, m^3\\,kg^{-1}\\,s^{-2}\\) \u2014 gravitational constant, - \\(M = 5.972 \\times 10^{24} \\, kg\\) \u2014 Earth's mass, - \\(m\\) \u2014 payload mass, - \\(\\mathbf{r}\\) \u2014 position vector from Earth's center, - \\(r = |\\mathbf{r}|\\) . The acceleration of the payload is: \\[ \\mathbf{a} = -\\frac{GM}{r^3} \\mathbf{r} \\]","title":"Theory"},{"location":"1%20Physics/2%20Gravity/Problem_3/#types-of-trajectories","text":"Elliptical orbit ( \\(0 \\leq e < 1\\) ) \u2014 payload is gravitationally bound to Earth. Parabolic trajectory ( \\(e = 1\\) ) \u2014 payload travels at exactly escape velocity. Hyperbolic trajectory ( \\(e > 1\\) ) \u2014 payload escapes Earth's gravity.","title":"Types of trajectories:"},{"location":"1%20Physics/2%20Gravity/Problem_3/#numerical-simulation","text":"To simulate the payload trajectory, we use the 4th-order Runge-Kutta (RK4) method to integrate the equations of motion numerically.","title":"Numerical Simulation"},{"location":"1%20Physics/2%20Gravity/Problem_3/#initial-conditions","text":"Initial altitude \\(h\\) (e.g., 200 km above Earth\u2019s surface), Initial velocity magnitude \\(v_0\\) and launch angle \\(\\theta\\) relative to horizontal, Initial position at \\((R_E + h, 0)\\) where \\(R_E\\) is Earth's radius.","title":"Initial conditions:"},{"location":"1%20Physics/2%20Gravity/Problem_3/#python-code","text":"```python import numpy as np import matplotlib.pyplot as plt","title":"Python Code"},{"location":"1%20Physics/2%20Gravity/Problem_3/#constants","text":"G = 6.67430e-11 # gravitational constant, m^3/kg/s^2 M = 5.972e24 # Earth mass, kg R_E = 6371000 # Earth radius, m def acceleration(r): \"\"\"Calculate gravitational acceleration at position r.\"\"\" norm_r = np.linalg.norm(r) return -G * M * r / norm_r**3 def rk4_step(r, v, dt): \"\"\"Perform one RK4 integration step.\"\"\" k1_v = acceleration(r) k1_r = v k2_v = acceleration(r + 0.5 * dt * k1_r) k2_r = v + 0.5 * dt * k1_v k3_v = acceleration(r + 0.5 * dt * k2_r) k3_r = v + 0.5 * dt * k2_v k4_v = acceleration(r + dt * k3_r) k4_r = v + dt * k3_v r_next = r + (dt / 6) * (k1_r + 2*k2_r + 2*k3_r + k4_r) v_next = v + (dt / 6) * (k1_v + 2*k2_v + 2*k3_v + k4_v) return r_next, v_next def simulate_trajectory(v0, theta_deg, h=200000, t_max=6000, dt=1): \"\"\" Simulate payload trajectory near Earth. Parameters: v0 - initial velocity magnitude (m/s) theta_deg - launch angle in degrees relative to horizontal h - initial altitude (m) t_max - simulation duration (s) dt - timestep (s) Returns: numpy array of trajectory points [[x1, y1], [x2, y2], ...] \"\"\" theta = np.radians(theta_deg) r = np.array([R_E + h, 0.0]) # initial position vector v = v0 * np.array([np.cos(theta), np.sin(theta)]) # initial velocity vector trajectory = [r.copy()] t = 0 while t < t_max: r, v = rk4_step(r, v, dt) trajectory.append(r.copy()) t += dt # Stop if payload hits the ground if np.linalg.norm(r) <= R_E: break return np.array(trajectory)","title":"Constants"},{"location":"1%20Physics/2%20Gravity/Problem_3/#example-simulations","text":"","title":"Example simulations:"},{"location":"1%20Physics/2%20Gravity/Problem_3/#three-scenarios","text":"","title":"Three scenarios:"},{"location":"1%20Physics/2%20Gravity/Problem_3/#1-sub-orbital-speed-1000-ms-45-degrees-angle","text":"","title":"1) Sub-orbital speed (1000 m/s), 45 degrees angle"},{"location":"1%20Physics/2%20Gravity/Problem_3/#2-orbital-speed-7800-ms-horizontal-0-degrees","text":"","title":"2) Orbital speed (~7800 m/s), horizontal (0 degrees)"},{"location":"1%20Physics/2%20Gravity/Problem_3/#3-above-escape-velocity-12000-ms-horizontal-0-degrees","text":"params = [ (1000, 45, 'Sub-orbital fall'), (7800, 0, 'Low Earth Orbit'), (12000, 0, 'Escape trajectory') ] plt.figure(figsize=(10,10)) earth = plt.Circle((0, 0), R_E, color='blue', alpha=0.3, label='Earth') plt.gca().add_artist(earth) for v0, theta, label in params: traj = simulate_trajectory(v0, theta) plt.plot(traj[:,0], traj[:,1], label=f'{label}, v0={v0} m/s, angle={theta}\u00b0') plt.xlabel('x (meters)') plt.ylabel('y (meters)') plt.title('Payload Trajectories Near Earth') plt.legend() plt.axis('equal') plt.grid(True) plt.show() Results Explanation At 1000 m/s and 45\u00b0, the payload falls back to Earth \u2014 velocity too low to sustain orbit. At ~7800 m/s and 0\u00b0, the payload enters a near-circular low Earth orbit. At ~12000 m/s and 0\u00b0, the payload escapes Earth\u2019s gravity on a hyperbolic trajectory. Conclusion The initial velocity magnitude and direction determine if the payload falls, orbits, or escapes Earth. Numerical integration with RK4 provides accurate trajectory prediction. This model is useful for mission planning, satellite deployment, and reentry analysis.","title":"3) Above escape velocity (~12000 m/s), horizontal (0 degrees)"},{"location":"1%20Physics/3%20Waves/Problem_1/","text":"\ud83c\udf0a Interference Patterns on a Water Surface Motivation Interference patterns provide a vivid, intuitive view of wave behavior. On a water surface, these patterns arise when waves from different sources overlap. The resulting pattern reveals how waves interact constructively or destructively depending on their relative phases and distances. This simple yet powerful model helps us grasp key concepts of wave physics. \ud83d\udd27 Problem Setup Regular Polygon Selection We choose a regular pentagon (5-sided polygon) for placing our wave sources. Parameters Amplitude (A): 1.0 Wavelength (\u03bb): 1.0 unit Frequency (f): 1.0 Hz Wave number (k): \\( k = \\frac{2\\pi}{\\lambda} \\) Angular frequency (\u03c9): \\( \\omega = 2\\pi f \\) Phase (\u03d5): 0 (coherent sources) \ud83e\uddee Wave Equation For a single source at location \\(\\vec{r}_i = (x_i, y_i)\\) , the wave displacement at point \\(\\vec{r} = (x, y)\\) and time \\(t\\) is: \\[ \\psi_i(x, y, t) = A \\cdot \\cos(k d_i - \\omega t + \\phi) \\] where: - \\(d_i = \\sqrt{(x - x_i)^2 + (y - y_i)^2}\\) The total wave displacement from all sources is: \\[ \\Psi(x, y, t) = \\sum_{i=1}^{N} \\psi_i(x, y, t) \\] \ud83e\uddd1\u200d\ud83d\udcbb Python Simulation Code import numpy as np import matplotlib.pyplot as plt # Parameters A = 1.0 wavelength = 1.0 k = 2 * np.pi / wavelength f = 1.0 omega = 2 * np.pi * f phi = 0 N_sources = 5 # regular pentagon # Time snapshot t = 0.0 # Grid x = np.linspace(-5, 5, 500) y = np.linspace(-5, 5, 500) X, Y = np.meshgrid(x, y) # Position sources at vertices of a regular pentagon radius = 2.0 angles = np.linspace(0, 2*np.pi, N_sources, endpoint=False) source_positions = [(radius * np.cos(a), radius * np.sin(a)) for a in angles] # Superpose waves from all sources Z = np.zeros_like(X) for (x0, y0) in source_positions: R = np.sqrt((X - x0)**2 + (Y - y0)**2) Z += A * np.cos(k * R - omega * t + phi) # Visualization plt.figure(figsize=(8, 6)) plt.contourf(X, Y, Z, levels=100, cmap='viridis') plt.colorbar(label='Wave Displacement') plt.scatter(*zip(*source_positions), color='red', label='Sources') plt.title('Interference Pattern from 5 Point Sources (Pentagon)') plt.xlabel('x') plt.ylabel('y') plt.legend() plt.axis('equal') plt.show() \ud83d\udd0d Analysis of Interference Patterns Constructive Interference Occurs where the waves from all sources arrive in phase \u2014 seen as bright (high-displacement) fringes. Destructive Interference Occurs where the waves are out of phase \u2014 seen as dark (low-displacement) regions. Symmetry Observed The pattern has pentagonal symmetry , reflecting the geometry of the source configuration. Regions of symmetry correspond to central lines between source pairs. \ud83d\udcc8 Conclusion This simulation of interference patterns from point sources arranged in a regular pentagon reveals: - Radial and angular symmetries matching the source geometry. - Rich, periodic structures caused by constructive and destructive interference. - A powerful way to explore wave superposition , using a visually intuitive and computationally accessible method.","title":"\ud83c\udf0a Interference Patterns on a Water Surface"},{"location":"1%20Physics/3%20Waves/Problem_1/#interference-patterns-on-a-water-surface","text":"","title":"\ud83c\udf0a Interference Patterns on a Water Surface"},{"location":"1%20Physics/3%20Waves/Problem_1/#motivation","text":"Interference patterns provide a vivid, intuitive view of wave behavior. On a water surface, these patterns arise when waves from different sources overlap. The resulting pattern reveals how waves interact constructively or destructively depending on their relative phases and distances. This simple yet powerful model helps us grasp key concepts of wave physics.","title":"Motivation"},{"location":"1%20Physics/3%20Waves/Problem_1/#problem-setup","text":"","title":"\ud83d\udd27 Problem Setup"},{"location":"1%20Physics/3%20Waves/Problem_1/#regular-polygon-selection","text":"We choose a regular pentagon (5-sided polygon) for placing our wave sources.","title":"Regular Polygon Selection"},{"location":"1%20Physics/3%20Waves/Problem_1/#parameters","text":"Amplitude (A): 1.0 Wavelength (\u03bb): 1.0 unit Frequency (f): 1.0 Hz Wave number (k): \\( k = \\frac{2\\pi}{\\lambda} \\) Angular frequency (\u03c9): \\( \\omega = 2\\pi f \\) Phase (\u03d5): 0 (coherent sources)","title":"Parameters"},{"location":"1%20Physics/3%20Waves/Problem_1/#wave-equation","text":"For a single source at location \\(\\vec{r}_i = (x_i, y_i)\\) , the wave displacement at point \\(\\vec{r} = (x, y)\\) and time \\(t\\) is: \\[ \\psi_i(x, y, t) = A \\cdot \\cos(k d_i - \\omega t + \\phi) \\] where: - \\(d_i = \\sqrt{(x - x_i)^2 + (y - y_i)^2}\\) The total wave displacement from all sources is: \\[ \\Psi(x, y, t) = \\sum_{i=1}^{N} \\psi_i(x, y, t) \\]","title":"\ud83e\uddee Wave Equation"},{"location":"1%20Physics/3%20Waves/Problem_1/#python-simulation-code","text":"import numpy as np import matplotlib.pyplot as plt # Parameters A = 1.0 wavelength = 1.0 k = 2 * np.pi / wavelength f = 1.0 omega = 2 * np.pi * f phi = 0 N_sources = 5 # regular pentagon # Time snapshot t = 0.0 # Grid x = np.linspace(-5, 5, 500) y = np.linspace(-5, 5, 500) X, Y = np.meshgrid(x, y) # Position sources at vertices of a regular pentagon radius = 2.0 angles = np.linspace(0, 2*np.pi, N_sources, endpoint=False) source_positions = [(radius * np.cos(a), radius * np.sin(a)) for a in angles] # Superpose waves from all sources Z = np.zeros_like(X) for (x0, y0) in source_positions: R = np.sqrt((X - x0)**2 + (Y - y0)**2) Z += A * np.cos(k * R - omega * t + phi) # Visualization plt.figure(figsize=(8, 6)) plt.contourf(X, Y, Z, levels=100, cmap='viridis') plt.colorbar(label='Wave Displacement') plt.scatter(*zip(*source_positions), color='red', label='Sources') plt.title('Interference Pattern from 5 Point Sources (Pentagon)') plt.xlabel('x') plt.ylabel('y') plt.legend() plt.axis('equal') plt.show()","title":"\ud83e\uddd1\u200d\ud83d\udcbb Python Simulation Code"},{"location":"1%20Physics/3%20Waves/Problem_1/#analysis-of-interference-patterns","text":"","title":"\ud83d\udd0d Analysis of Interference Patterns"},{"location":"1%20Physics/3%20Waves/Problem_1/#constructive-interference","text":"Occurs where the waves from all sources arrive in phase \u2014 seen as bright (high-displacement) fringes.","title":"Constructive Interference"},{"location":"1%20Physics/3%20Waves/Problem_1/#destructive-interference","text":"Occurs where the waves are out of phase \u2014 seen as dark (low-displacement) regions.","title":"Destructive Interference"},{"location":"1%20Physics/3%20Waves/Problem_1/#symmetry-observed","text":"The pattern has pentagonal symmetry , reflecting the geometry of the source configuration. Regions of symmetry correspond to central lines between source pairs.","title":"Symmetry Observed"},{"location":"1%20Physics/3%20Waves/Problem_1/#conclusion","text":"This simulation of interference patterns from point sources arranged in a regular pentagon reveals: - Radial and angular symmetries matching the source geometry. - Rich, periodic structures caused by constructive and destructive interference. - A powerful way to explore wave superposition , using a visually intuitive and computationally accessible method.","title":"\ud83d\udcc8 Conclusion"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/5%20Circuits/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/5%20Circuits/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_2/","text":"Problem 2","title":"Problem 2"},{"location":"1%20Physics/6%20Statistics/Problem_2/#problem-2","text":"","title":"Problem 2"},{"location":"1%20Physics/7%20Measurements/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/7%20Measurements/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"2%20Mathematics/1%20Linear_algebra/","text":"Linear Algebra","title":"Linear Algebra"},{"location":"2%20Mathematics/1%20Linear_algebra/#linear-algebra","text":"","title":"Linear Algebra"},{"location":"2%20Mathematics/2%20Analytic_geometry/","text":"Analytic geometry","title":"Analytic geometry"},{"location":"2%20Mathematics/2%20Analytic_geometry/#analytic-geometry","text":"","title":"Analytic geometry"},{"location":"2%20Mathematics/3%20Calculus/","text":"Calculus","title":"Calculus"},{"location":"2%20Mathematics/3%20Calculus/#calculus","text":"","title":"Calculus"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_02%20Set_Theory/","text":"Set Theory","title":"Set Theory"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_02%20Set_Theory/#set-theory","text":"","title":"Set Theory"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_03%20Relations/","text":"Relations","title":"Relations"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_03%20Relations/#relations","text":"","title":"Relations"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_04%20Functions/","text":"Functions","title":"Functions"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_04%20Functions/#functions","text":"","title":"Functions"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_05%20Combinatorics/","text":"Combinatorics","title":"Combinatorics"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_05%20Combinatorics/#combinatorics","text":"","title":"Combinatorics"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_08%20Number_Theory/","text":"Number Theory","title":"Number Theory"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_08%20Number_Theory/#number-theory","text":"","title":"Number Theory"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_06%20Sequences_and_Series/","text":"Sequences and Series","title":"Sequences and Series"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_06%20Sequences_and_Series/#sequences-and-series","text":"","title":"Sequences and Series"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_07%20Induction/","text":"Induction","title":"Induction"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_07%20Induction/#induction","text":"","title":"Induction"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_09%20Recurrence/","text":"Recurrence","title":"Recurrence"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_09%20Recurrence/#recurrence","text":"","title":"Recurrence"},{"location":"3%20Discret_Mathematics/4%20Graph%20Theory%20and%20.../_10%20Graph_Theory/","text":"Graph Theory","title":"Graph Theory"},{"location":"3%20Discret_Mathematics/4%20Graph%20Theory%20and%20.../_10%20Graph_Theory/#graph-theory","text":"","title":"Graph Theory"},{"location":"3%20Discret_Mathematics/5%20Logic/_01%20Logic/","text":"Logic","title":"Logic"},{"location":"3%20Discret_Mathematics/5%20Logic/_01%20Logic/#logic","text":"","title":"Logic"}]}